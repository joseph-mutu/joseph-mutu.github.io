---
layout:     post   				    # 使用的布局（不需要改）
title:      剑指Offer(长期) 				# 标题 
subtitle:   data structure          #副标题
date:       2019-07-05 				# 时间
author:     WYX 						# 作者
header-img: img/music0.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - data structure  

---



# 剑指 offer 笔记

本文长期记录剑指 Offer 刷题中需要注意的点

---

### 二维数组中的查找

> 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数

#### **自己的想法**

用二分法搜索每一行。如果一行的第一个值大于想要的数字，则退出。先判定数组是否为空，为空的话返回 False

**注意**：系统输入的是一个二维的空列表，判定大小要注意

```
array = [[]]
# 使用 len 判定数组是否为空有问题,len(array) 输入为1
```

#### 讨论中的想法：

从左下开始搜索，如果当前数据大于 want_num 则向上移动一位；如果当前数据小于 want_num 则向右移动一位；梯度上升



### 替换空格

> 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

#### 自己的想法

使用python 内置函数 replace 直接进行替换

```python
a = 'asd2 qweasda'
a = a.replace(' ','%20')
```

#### 讨论（可以查看在线解析）

- 首先扫描字符串中一共有多少个空格
- 在字符串后面添加 2 * num_space 的任意字符
- 使用两个变量分别记录真正的字符串的最后一位以及添加字符串的最后一位
- 两个变量同时向前移动
  - 如果真正的字符串当前指的不是空格，则将当前指的值赋值给添加字符串当前的位置
  - 如果真正的字符串当前指的是空格，则将添加字符串位置向前移动三位，并在移动过程中添加 “%20”

![替换空格](https://ae01.alicdn.com/kf/HTB1F9JtXxv1gK0jSZFF7620sXXaa.png)

在增加字符串长度的过程中，首先将字符串转为了 list，然后在list后面添加

```python
string = list(s)		
string2 = ['0' for i in range(num_space*2)]
string += string2
```



### 从尾到头打印列表

> 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。

#### 自己的想法

- 将链表每一个值从头到尾储存在一个列表中
- 将列表翻转. 
  - list.reverse()
- 打印列表

#### 讨论

进行递归调用

终止条件为：

- 当列表当前值为 None 时，表示当前访问 Node 为最后一个值的下一个值。则返回空列表 []

```python
 if listNode is None:
        	return []
        else:
        	return self.printListFromTailToHead(listNode.next) + [listNode.val]
```



### 重建二叉树

> 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

#### 自己的想法

递归求解

以下图的二叉树为例

 <center>
    <img src="https://github.com/joseph-mutu/Pics/raw/master/reconstruct binary trees(jianzhi).jpg" width="200"/>
</center>

根据前序以及中序遍历的结果，可以恢复二叉树。

- 前序遍历的结果中，首位的数是**当前**二叉树的**根节点**
- 根据当前二叉树的根节点，在中序遍历结果中，根据当前子树的length，查找其左右子树
  - 如，初始情况下，当前二叉树的根节点为 1
  - 在 in 列表中定位 1，当前二叉树的 length 为 6。1 在 in 列表中的位置为 3（从 0 开始）。则其左子树长度为 3（左子树中存在 3 个元素）。右子树的长度的 “当前二叉树长度 - 左子树长度 - 1 ”
- 递归求解左子树以及右子树。将左子树视为当前二叉树。移动 pre 列表中的首位元素（根据左子树长度以及右子树长度进行分别移动到左右子树的根节点）。
- 对于当前左子树来说，根节点为  2。对于当前右子树来说，根节点为 5
  - 求解左子树
    - 左子树长度为 3。则当前二叉树长度为 3。在 in 数组中定位到其根节点 2，索引为 1。则左子树的左子树长度为 1 - 0 = 1。左子树的右子树长度为 3 - 1 -1 = 1。
  - 求解右子树
    - 右子树长度为 2。则当前二叉树长度为 2。在 in 数组中定位其根节点 5，索引为 5。则右子树的左子树长度为 5 - 4 = 1。右子树的右子树长度为 2 - 1 - 1=0
      - 注意对于右子树来说，in 数组的起始索引为 4。

##### 递归终止条件

由上述描述可知，两种情况

- 子树长度为 1。则当前传入节点为叶节点。即 cur_node.left = None. cur_node.right = None
- 子树长度为 0。当前传入节点无叶节点。直接返回

