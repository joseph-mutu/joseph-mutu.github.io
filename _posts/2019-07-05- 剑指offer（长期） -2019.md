---
layout:     post   				    # 使用的布局（不需要改）
title:      剑指Offer(长期) 				# 标题 
subtitle:   data structure          #副标题
date:       2019-07-05 				# 时间
author:     WYX 						# 作者
header-img: img/5.1.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - data structure  

---



# 剑指 offer 笔记

本文长期记录剑指 Offer 刷题中需要注意的点

---

### 二维数组中的查找

> 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数

#### **自己的想法**

用二分法搜索每一行。如果一行的第一个值大于想要的数字，则退出。先判定数组是否为空，为空的话返回 False

**注意**：系统输入的是一个二维的空列表，判定大小要注意

```
array = [[]]
# 使用 len 判定数组是否为空有问题,len(array) 输入为1
```

#### 讨论中的想法：

从左下开始搜索，如果当前数据大于 want_num 则向上移动一位；如果当前数据小于 want_num 则向右移动一位；梯度上升



### 替换空格

> 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

#### 自己的想法

使用python 内置函数 replace 直接进行替换

```python
a = 'asd2 qweasda'
a = a.replace(' ','%20')
```

#### 讨论（可以查看在线解析）

- 首先扫描字符串中一共有多少个空格
- 在字符串后面添加 2 * num_space 的任意字符
- 使用两个变量分别记录真正的字符串的最后一位以及添加字符串的最后一位
- 两个变量同时向前移动
  - 如果真正的字符串当前指的不是空格，则将当前指的值赋值给添加字符串当前的位置
  - 如果真正的字符串当前指的是空格，则将添加字符串位置向前移动三位，并在移动过程中添加 “%20”

![替换空格](https://ae01.alicdn.com/kf/HTB1F9JtXxv1gK0jSZFF7620sXXaa.png)

在增加字符串长度的过程中，首先将字符串转为了 list，然后在list后面添加

```python
string = list(s)		
string2 = ['0' for i in range(num_space*2)]
string += string2
```



### 从尾到头打印列表

> 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。

#### 自己的想法

- 将链表每一个值从头到尾储存在一个列表中
- 将列表翻转. 
  - list.reverse()
- 打印列表

#### 讨论

进行递归调用

终止条件为：

- 当列表当前值为 None 时，表示当前访问 Node 为最后一个值的下一个值。则返回空列表 []

```python
 if listNode is None:
        	return []
        else:
        	return self.printListFromTailToHead(listNode.next) + [listNode.val]
```



### 重建二叉树

> 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

#### 自己的想法

递归求解

以下图的二叉树为例

 <center>
    <img src="https://github.com/joseph-mutu/Pics/raw/master/reconstruct binary trees(jianzhi).jpg" width="200"/>
</center>

根据前序以及中序遍历的结果，可以恢复二叉树。

- 前序遍历的结果中，首位的数是**当前**二叉树的**根节点**
- 根据当前二叉树的根节点，在中序遍历结果中，根据当前子树的length，查找其左右子树
  - 如，初始情况下，当前二叉树的根节点为 1
  - 在 in 列表中定位 1，当前二叉树的 length 为 6。1 在 in 列表中的位置为 3（从 0 开始）。则其左子树长度为 3（左子树中存在 3 个元素）。右子树的长度的 “当前二叉树长度 - 左子树长度 - 1 ”
- 递归求解左子树以及右子树。将左子树视为当前二叉树。移动 pre 列表中的首位元素（根据左子树长度以及右子树长度进行分别移动到左右子树的根节点）。
- 对于当前左子树来说，根节点为  2。对于当前右子树来说，根节点为 5
  - 求解左子树
    - 左子树长度为 3。则当前二叉树长度为 3。在 in 数组中定位到其根节点 2，索引为 1。则左子树的左子树长度为 1 - 0 = 1。左子树的右子树长度为 3 - 1 -1 = 1。
  - 求解右子树
    - 右子树长度为 2。则当前二叉树长度为 2。在 in 数组中定位其根节点 5，索引为 5。则右子树的左子树长度为 5 - 4 = 1。右子树的右子树长度为 2 - 1 - 1=0
      - 注意对于右子树来说，in 数组的起始索引为 4。

##### 递归终止条件

由上述描述可知，两种情况

- 子树长度为 1。则当前传入节点为叶节点。即 cur_node.left = None. cur_node.right = None
- 子树长度为 0。当前传入节点无叶节点。直接返回



### 用两个栈模拟队列

> 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

#### 想法



<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E4%B8%A4%E4%B8%AA%E6%A0%88%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97.png" width ="400"/>
</center>





分为 Push 操作和 pop 操作，模拟的是队列的先进先出原则

- Push 操作将每一个元素按照栈的操作先压到第一个栈中。如上图第一个栈的 A,B,C,D
- Pop 操作首先判断第二个栈是否为空
  - 如果为空，将第一个栈的所有元素按照 pop 的顺序压到第二个栈中。此时顺序调换
    - 如D,C,B,A 此时被压到第二个栈中
    - Pop 第二个栈的元素。模拟先进先出
  - 如果不为空，则 return 第二个栈的pop元素





### 旋转数组里的最小数字

> 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
> NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

##### 题目理解

原数组为一个**非递减**数组。但是输入数组为经过旋转之后的数组。此题只考虑旋转一次或者没有旋转的情况。

- 非递减意味着，数组中可能存在重复的元素。即[1,1,0,1,1] 这样的数组也存在于输入中





<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.jpg" width = "300"/>
</center>



- 原数组在进行旋转之后，输入数组可以分为两部分。**且两部分顺序皆为非递减排序**。**且第一部分元素皆大于等于第二部分元素**。即上述白色以及灰色部分
  - 旋转数组的最小值在旋转数组两部分的分界处。即要找到原数组的第一个值



##### 题目解法

使用二分法。但是每次要保证两个指针不会彼此错位。即第一个指针要始终在第一部分移动(白色)，第二个指针始终在第二部分移动（灰色）。

###### 如何保证指针彼此不错位

P1 初始位置指向输入数组的第一个值。P2 初始位置在输入数组的最后一个值。

- 首先选取中间值。 mid = (int) (P1 + P2)/2
- 中间值有两个可能。在白色区域，或者在灰色区域。
  - 在白色区域，则中间值比 P1 此刻的值大（相等）。
    - 将 P1 指向中间值所在的位置
  - 在灰色区域，则中间值比 P2 此刻的值小（相等）。
    - 将 P2 指向中间值所在的位置



但是上述解法没有考虑到特殊情况。（原数组为**非递减数组**）



###### 题目特例

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%EF%BC%88%E7%89%B9%E4%BE%8B%EF%BC%89.jpg" width = "600"/>
</center>

- 如果中间值与 P1 和 P2 值完全相等。则无法判断中间值处于哪一个区域。则只能用顺序查找进行
- 第二种特例。如果在开始的时候，P1 的值就小于 P2 的值。则数组没有旋转。直接输出 P1



### 青蛙跳台阶以及变态跳台阶

#### 青蛙跳台阶

> 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

##### 题目理解

斐波那契数列的应用。从只有一级台阶分析

- 1 级台阶。只有一种跳法。f(1) = 1
- 2 级台阶。有 2 种跳法。1 + 1/2。f(2) = 2
- 3 级台阶。可以从  1 级台阶跳到 3 级 / 从 2 级台阶跳到 3 级。所以 f(3) = f(1) + f(2)
  - 注意从 1 级到 3 级只有一种跳法 1 + 2。从 1 级先到 2 级再到 3 级这种情况已经被 f(2) 囊括在内（1+1+1）





#### 变态跳台阶

> 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

题目理解

从只有一级台阶分析

- 1级台阶。一种跳法
- 2 级台阶。2 种跳法。从 0 到 2/ 从  1到 2
- 3 级台阶。0 -> 3 / 1->3 / 2->3 = f(0) + f(1) + f(2)。因为无论几级台阶都能直接跳。则设定  f(0) =  1
- 4 级台阶。f(0) + f(1) + f(2) + f(3)
- ...

假设求 f(4) = f(0) + f(1) + f(2) + f(3)，有

- 因为 f(3) = f(0) + f(1) + f(2)
- 则 f(4) = 2*f(3)

以此类推

- f(n) = 2*f(n-1)



### 矩形覆盖

> 我们可以用2 * 1的小矩形横着或者竖着去覆盖更大的矩形。请问用 n个 2 * 1的小矩形无重叠地覆盖一个2 * n的大矩形，总共有多少种方法？

#### 题目理解

从只有一个矩形来看。

- 当矩形只有一个时，显然，只有一种方法覆盖
- 当矩形存在两个时。存在两种方法。一种竖着一种横着。**注意**，矩形的顺序无影响。

<center>
    <img src ="https://github.com/joseph-mutu/Pics/raw/master/%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%961.png" width = "500"/>
</center>

- 当矩形的存在为 3 个时，如下图所示。因为增加了一个小矩形，就增添了一种横着放的可能（下图，从 f(1) 到 f(3)）。

  <center>
      <img src= "https://github.com/joseph-mutu/Pics/raw/master/%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%962.png" width = "500"/>
  </center>

  

由以上可以得出，矩形覆盖 f (n) 依赖于其前两个状态 f(n-1) f(n-2)



### 二进制中 1 的个数

> 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

#### 题目理解

##### 原码，反码以及补码表示

8 的二进制**原码**表示为：


$$
1000: 0 \times 2^0 + 0 \times 2^1 + 0 \times 2^2 + 1 \times 2^3
$$


所谓反码即为将原码中 **1** 与 **0** 互换，如上述 8 的反码为：


$$
1000 \Rightarrow_{反码} 0111
$$


在 32进制中，数字使用补码来表示负数。所谓补码，即反码 + 1。且最高位为符号位（0 表示正数，1 表示负数。符号位在变为反码的过程中不变化）。下述为 -1 的反码表示。


$$
原码:~ 1(符号位)000 ~ 0000 ~ 0000 ~ 0000 ~ 0000 ~ 0000 ~ 0000 ~ 0001
$$

$$
反码：~1(符号位)111 ~1111 ~1111 ~1111 ~1111 ~1111 ~1111 ~1110
$$

$$
补码（反码 + 1）~ : ~1(符号位)\underbrace{111 ~1111 ~1111 ~1111 ~1111 ~1111 ~1111 ~1111}_{序号位}
$$

##### 一般情况下如何求 1 的个数（针对正数）

以 12 举例，在 32 位的情况下，12 的二进制原码表示如下：


$$
0000 ~ 0000 ~ 0000 ~ 0000 ~ 0000 ~ 0000 ~ 1100
$$


现在将 12 减去 1，为 11 ，观察 11 的二进制码


$$
1100 \Rightarrow 1011 : 1 \times 2^0 + 1 \times 2^1 + 0 \times 2^2 + 1 \times 2^3 = 11
$$
观察得到，将一个数，减去1之后所得到的二进制码**只改变原数**二进制原码，**最右边**的1，并将最右边的1之后的 0 取反。

则，若将 12-1 与 12 再次进行位与运算，如下


$$
\begin{equation}
位与 \left\{
\begin{aligned}
& 1001 \\
& 1100 \\
\end{aligned}
\right.
\end{equation}

\Rightarrow 1000
$$


则次操作可以视为，消去最右边一个 1。重复此操作，直至最后结果为 0 为止。



**Note:**

在 python 中，负数 不可使用上述的方法，会陷入循环。因为python 中不使用补码的形式表示负数。

##### 解决方法

```python
n = n if n > 0 else n & 0xFFFFFFFF
```

将 -1 & 0xFFFFFFFF, 可以将 -1 的补码形式转换成一个无符号数，也就是其补码形式相对应的正数。从而再进行操作。



### 数值的整数次方

> 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。

#### 题目理解

1. 拿到题目首先要确定题目的特例
   1. 任何数的 0 次幂为 1
   2. 0 的任除1外的任何次幂皆为 0 
   3. 负数次幂为其正数次幂的倒数
      1. 注意特例， 0/任何数 无意义



#### 题目解法

使用快速幂，而不是如下所示每次叠加一次

##### 低效率

```python
for i in range(numExponent):
    base *=base
return base
```



##### 快速幂分析

任何整数均可以表示为二进制形式，如 12 的二进制形式如下：


$$
1100 : ~ 0 \times 2^0  + 0 \times 2^0 + 1\times 2^2 + 1 \times 2^3
$$


则如果要求 $2^{12}$ , 则可以将其分解为如下形式：


$$
2^{12} = 2^{0 \times 2^0  + 0 \times 2^0 + 1\times 2^2 + 1 \times 2^3} \\
\space  \\
=2^{0 \times 2^0} * 2^{0 \times 2^0} *2^{1\times 2^2 } *2^{1 \times 2^3}
$$


note：在上述形式中，只有当当前的二进制码为 1 的时候，才进行相乘。则算法的想法为：

- 从右边的第一个二进制码开始，如果当前的二进制码为  1 ，则与当前的 curBase 相乘
- 如果当前的二进制码为 0，则只累计 curBase
- 将当前的 exponent 移位
  - 以 12 举例。其当前的二进制表示为 1100。
  - 此时判断其二进制表示的最后一位是否为 1
  - 将 12 向右移动一位
    - 0110： $2^0 \times 0 + 2^1 \times 1 + 2^2 \times 2 = 6$
  - 循环判断，当 exponent 移位至 0 时，结束判断

```python
while exponent:
    if exponent & 1:
        ans *= curBase
        curBase *= curBase
    exponent >>= 1
```

##### 技巧

- 使用左移右移代替乘法除法

  - 左移为乘法

  - 右移为除法

    - ```python
      3<<1
      输出为：1，相当于 int(3/2)
      ```





### 调整数组的顺序，使奇数位于偶数前面

> 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

#### 题目解法

以如下数组举例


$$
[2,3,4,0,5,6]
$$

- 从头开始判断。以 temCount 记录操作的次数。当操作的次数与原数组长度相同时，结束

- 如果当前的位置元素为偶数，则将当前元素添加到数组的尾端，并从原数组中删除该元素

  
  $$
  [3,4,0,5,6,2]
  $$

- 当前位置元素为奇数时，操作数Count + 1，并 `Continue`



### 链表中倒数第K个节点

> 输入一个链表，输出该链表中倒数第k个结点。

#### 自己的想法

- 遍历链表，同时开辟一个列表存储所有的值
- 返回倒数第K个值

#### 无需开辟新数组的想法

利用两个指针，一前一后行成一个**“尺子”**, 当尺子的前端（离起点较远的那一端）到达链表的末尾时，此时尺子头所在的位置即为倒数第  K 个数字。如下图所示

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9.png" width = "800"/>
</center>

- 首先初始化两个指针为链表头。
- 将其中一个指针向前移动 K - 1 个位置。这样保证当尺子前端到达链表末尾的时候，尺子后端为倒数第K个数。
  - 这里需要注意判断边界条件，在移动尺子一端的时候，可能会出现两种情况
    - 尺子移动 K - 1 个位置刚好到达链表的末尾。也就是 `尺子前端.next = None`
    - 尺子移动 K - 1 个位置的过程中，超出了链表。此时输入不合法，返回 None
- 尺子定义完成后，只需要同时向前移动尺子的**“前端”**和**"后端"**，当前端达到末尾，返回后端



### 反转链表

> 输入一个链表，反转链表后，输出新链表的表头。

反转链表时需要三个变量。输入链表为单向的，如果直接反转的话，会失去原本的 next 值。

- 创建一个 next 值，在反转当前值之前记录其 next 的位置。
- 创建 last 值，记录当前值的前一个节点的位置。
- 不断移动当前值

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.png" width = "800"/>
</center>

最后需要返回的是 **last** 值。因为在处理最后一个节点时，pHead 成为 None

```python
pLast = None
while pHead:
    pNext = pHead.next
    pHead.next = pLast
    pLast = pHead
    pHead = pNext
return pLast
```

