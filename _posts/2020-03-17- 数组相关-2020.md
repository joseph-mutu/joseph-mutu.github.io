---
layout:     post   				    # 使用的布局（不需要改）
title:      数据结构-数组				# 标题 
subtitle:   数组           #副标题
date:       2020-03-16 				# 时间
author:     WYX 						# 作者
header-img: img/1.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 数组 

---

---

本文记录数组相关数据结构

---



## 数组

### 回文

#### 409 最长回文串

**解法**

只要求求给定字符能组成的最长的回文串长度。回文串具有以下特性

- 除中心外，其余字符出现次数皆为偶数

给定一个字母其出现的次数为 $x$ ，则该 $x$ 对回文子串贡献的长度为 $\frac{x}{2} * 2$  

遇到第一个出现奇数次的字母时，抽取一个当做中心

#### 5 最长回文子序列

**传统解法**

选中中心点进行扩展，如果两边字母一样，则两边同时向外增加，左边 -- ，右边 ++ 

- 选定中心扩展时，选取的中心不仅是字符串中的字符，还有字符串中的空格


  $$
  c~b~a~b~c
  $$

  

- 给定上述字符串，中心分别为 `c，(空格),b,(空格),a,(空格),b,(空格),c,(空格)`

  - 具体不同在于扩展时给定的左右字符不同
    - 中心为字符时，以第一个c举例，其` expandAroundCenter` 的 Left 和 Right 为 $i,i$，其中 i 为 c 的 index，也就是 0
    - 中心为字母是，以第一个 c 右边的空格举例，其 `expandAroundCenter` 的 Left 和 Right 分布为 $i,i+1$ ，其中 i 为 c 的 index，也就是 0

- 给定中心 index，给定距离，计算 start

  - $start = i - int(\frac{len-1}{2})$
  - $end = i  + int(\frac{len}{2})$

遍历所有的中心点，记录最大的回文长度

#### 658 最接近的 k 个数

**解法**

使用二分法一次找到最终边界的左边界

![](https://github.com/joseph-mutu/Pics/raw/master/data structure/lc658.png))

#### 128 最长连续序列

给定一个不排序的数组，找到最长的连续序列，要求时间复杂度为 $O(n)$

> Input: [100, 4, 200, 1, 3, 2]
> Output: 4
> Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4

- 将数字用 set 存储，以便查找效率为 $O(1)$
- 遍历一遍数组，只有当 num - 1 不在数组中时，才开始查找 num, num+1,num+2...
  - 因为只有当 num - 1不在数组中时，才不会出现重复查找的情况
  - 否则根据上述给定的输入先查找 4，再查找 1234，再查找 3,4，再查找 2,3,4

#### 189 旋转数组

如何循环遍历位置

- 假设数组长度为 4，某一个位置一直向前移动 k 次，当 k 大于数组长度时，其最终位置为

```python
(i + k)%len(nums)
```

#### 283 移动 0

将数组所有的零移动到末尾，且要保证其他数字的相对顺序

使用两个指针，

- 一个位置指针，指明当前移动的位置，从0开始
- 一个寻找非零的指针，遇到非零的数字停下

```python
for i in range(len(nums)):
	if nums[i]:
        nums[i],nums[pos] = nums[pos],nums[i]
    pos += 1
```

#### 面试题 57 和为 s 的正整数序列

给定一个 target，要求找到和为 target 的所有连续的正整数序列

首先判断最后一个可能的起始点为 `target//2`，以 9 为例，不可能有序列以 5 开始

**解法1**

因为为连续的正整数序列，所以可以用等差数列求和公式，给定一个起始点，利用二次方程的求根公式判断是否存在序列

- 注意二次方程的求根求的是从该起点到 target 所需要的步长，如果该步长为整数，则该起点可以

**解法2**

利用滑动窗口求解

> 所谓滑动窗口就是，左边界以及右边界只能向右移动，不会向左移动

从 left = 0 以及 right = 0 开始

`tem_sum = left`

```python
tem_sum = left
while left <= target//2:
    if tem_sum > target:
        tem_sum -= left
        left -= 1
    elif tem_sum < target:
        right += 1
        tem_sum += right
   	elif tem_sum == target:
        tem_sum -= left
        left + =1
```

- 如果当前窗口的和小于 target 则，右边界向右移动，
- 如果当前窗口的和大于 target，则左边界向右移动，减去最小的一个值
- 如果当前窗口的和等于 target，则左边界向右移动，寻找新的起点

#### 402 移除 K 个数字变成最小数

题目关键在于如何移除 K 个数字

- 移除 K 个数字后，所有可能的数字都有一样的长度
  - 所以大小取决于开头的数字

以 546 举例

- 移除 4 为 56
- 移除 5  为 46
- 移除 6 为 54

从 第二位开始，如果当前位置比前一位小，则移除前一位

- 先 `append` 5，移动到 4
  - 如果不删除 5，则 5 开头，无论如何都不可能是最小的

> 假设数字为增序排列

如 
$$
123456
$$


则最小的即为前 K 个数字

> 注意删除之后有前置 0 ，比如 10200，删除完为 0200

使用 `lstrip(0)` 删除所有左 0

> 注意删除完之后，数字为空，此时返回 0

此处利用 `or` 操作

```python
0 and 10
>>> 0
0 or 10
>>> 10
```

#### 面试题 10.01 合并排序数组

给定两个排序数组，且第一个数组为第二个数组留有足够的位置，要求合并两个数组

两个数组从后向前遍历，定义一个元素，从第一个数组的最后空余位置开始向前遍历

- 若第一个数组 `end_A == -1` 说明第一个数组遍历完毕

```python
A[merge_end] = B[end_B]
end_B -= 1
```

-  若第二个数组 `end_B -= 1` 说明第二个数组遍历完毕，逐一将前面的数字替换为第二个数组的数字
-  若第一个数组当前元素大于等于第二个数组当前元素，则将后面填上第一个数组当前值
   - 否则，将后面填上第二个数组当前值

#### 寻找排列数组中的元素最小值

题目保证数组中没有重复的元素

利用双指针，使用二分查找，每次保证 `start` 指针指向旋转数组，`second` 指针指向排序数组

-  注意考虑将前 0 个元素旋转的情况，也就是没有旋转
-  若第一个元素小于等于最后一个元素，则直接返回第一个元素

当两个指针距离等于 1 时，返回 `second` 指针指向的元素 

#### 26 从排列数组中移除重复元素

**解法**

利用两个指针

- 当两个指针指向元素相同时，`second` 指针向前动
- 当两个指针指向元素不同
  - `first` 指针先向前移动
  - 将`second` 指针元素赋给 `first` 当前位置

最终 `first` 所在位置 + 1即为所有不同元素的个数。+1 是因为数组从 0 开始

#### 46 全排列 

**解法**

递归的过程中进行交换

```python
def permute(start):
    if start == len(nums):
        self.permutation.append(nums[:])
        
    for i in range(start,len(nums)):
        nums = swap(start,i)
        self.permute(start + 1)
        nums = swap(start,i)
```

以 `1,2,3` 进行分析，起始 `start` 为 0

- 刚开始 i 有 `0,1,2` 三个值可以迭代
  - `i = 0` ，与自己交换，等于没有操作，数组仍然为 `123`，再次进入递归 `start = 1`
    - 有 `1,2` 两个值可以迭代，`i = 1，start = 1`，与自己交换，等于没有操作，数组仍然为 `123`
      - 只有 1 个值可以迭代 `start = 2, i= 2`, 与自己交换，等于没有操作，进入递归
        - `start = 3` 与 length 相等，添加数组 `123` 返回 
      - 迭代终止，返回
    - 交换 `start = 1,i  = 1` 等于没有交换，
    - 第二次迭代`start = 1,i = 2` ，进行交换，数组为 `132` ，进入递归
      - `start = 2,i=2` 只有一个值可以迭代，自己与自己交换，等于没有操作
        - `start = 2 == len(nums) `， 迭代终止，添加数组 132
        - 返回
      - 迭代终止，返回
    - 迭代终止，返回
  - `start = 0,i=0`, 交换 `0,0` 位置，等于没有操作，继续迭代
  - `start = 0,i =1` ，进行交换，数组变为 `213`，进入迭代
    - `start = 1,i =1`
    - ...

#### 238 除自身以外的数组乘积

不可使用除法，输出一个数组，除自身以外的乘积

**解法**

`乘积 = 当前数字左边乘积 x 当前数字右边乘积`

- 建立左数组乘积，存储当前数字的左乘积
- 建立右数组乘积，存储当前数字的右乘积
- 将当前数字左右两边相乘，输出列表

Note: 第一个数字的左数组乘积为 1，最后一个数字的右数组乘积也为 1

**优化**

为了优化空间，可以直接在输出数组中进行左数组以及右数组乘积的运算

- 先遍历一遍列表，输出数组中存储左数组乘积
- 从后往前遍历，利用 R 存储右数组乘积，不断更新

#### 75 颜色排序

**解法**

进行三划分，定义不同区间，实现原地排序。题目中数组只包含 三个元素，要求实现三个元素的原地排序，且只能遍历一次数组

首先定义区间

- `[0,one_interval) = 0`
- `[one_interval,i)` = 1
- `[two:]` = 2

根据上述定义，当  i >= two_interval 时，退出循环

```python
当 i 为 0 时，交换 one_interval 与 i 的值
	i += 1
	one_interval += 1
当 i = 1 时
	i +=1 
else:
    two_interval -= 1
    swap(i,two_interval)
	
```



#### 48 旋转图像

**解法**

难点在于确定交换数据的坐标值

**Note: 在确定交换时的坐标时，把握住谁在变化，是行在变化还是列在变化**

- 使用两层循环，外圈 `i` 每一次循环对矩阵的每一圈完成旋转的操作，到 $\frac{n}{2}$ 为止
- 内圈到 $len(行长度) - 1 - i$ 为止

```python
for i in range(int(length/2)):
    for j in range(i,length - 1 - i):
        tem = matrix[i][j]
        matrix[i][j] = matrix[length - 1 - j][i]
        matrix[length - 1 - j][i] = matrix[length - 1 - i][length - 1 - j]
        matrix[length - 1 - i][length - 1 - j] = matrix[j][length - 1 - i]
        matrix[j][length - 1 - i] = tem
```

外圈 `i` 到 `int(length/2) ` 为止表示旋转时不用超过对角线

- 因为上述操作每次对一整圈进行旋转

#### 98 验证二叉搜索树

**解法**

使用递归分别验证根节点的左子树与右子树

- 为了保证左子树的所有节点均为小于根节点的值，需要添加一个 **upper_bound**
- 为了保证右子树的所有节点均为小于根节点的值，需要添加一个 **lower_bound**

#### 3 最长无重复子串

**解法**

使用 set 记录出现过的字符，使用 left 和 right 标识当前的子串长度，遍历字符串

- 每访问一个新的字符，right +1，标识当前长度加 1 

- 若当前字符曾在之前的字符串中出现过，将 left 不断向前移动，同时从 set 中删除相应的元素，直到当前字符为新字符为止
- 计算长度，并更新最大长度

#### 121 买卖股票的最佳时机

给定一个数组，求最大的差值，要求第一个数小，第二个数大

**解法**

遍历一次数组

```python
min_buy = sys.maxsize
max_prof = float('inf')
```

- 记录当前的最小值 

```python
min_buy = min(prices[i],min_buy)
```

- 对最大差值进行更新

```python
max_prof = max(max_prof, prices[i] - min_buy)
```

#### 17 电话号码的字母组合

**解法**

- 建立电话号码与其对应的字母的字典

- 按照给定的数字将相应的字母以列表的形式存储在一起

  - 假设输入为 "23"，则相应的存储为

  $$
  [['a','b','c'],['d','e','f']]
  $$

  

- 利用递归完成所有可能的排列组合

#### 33 在旋转数组中进行搜索

**解法**

- 根据中间数以及数组右边的数挑选出一定有序的一边
  - `nums[mid] < nums[right]`  表示 mid 数左边有序
  - 如果使用 数组最左边的数进行判断，则需要更改条件为 `nums[mid] >= nums[left]`
    - 对应情况为两个数的情况，假设数组为 $[8,0]$，target = 0
      - 则 left 为 8，right 为 0. 中间数为 8。若条件为 `nums[mid] > nums[left]`
      - 则当前条件不满足，则为 右边有序
      - 当判定到右边时，target 需要满足 `target >= nums[right] and target <= nums[mid]`
      - 此时 mid 为 8，右边 为 0，则判断失误，right 指针移到 left，return -1
      - 无法找到 0

- 利用有序的一遍判断 target 数值在中间数的左边还是右边

#### 8 字符串转换整数

给定一个字符串，判断是否为合法的可转换字符串，若合法则进行转换，否则返回 0。其中转换后整数需要在 $[2^{31} -1, -2^{31}]$ 范围内

**解法**

使用正则表达式以及 `string.lstrip()` 函数

- `string.lstrip()` 函数将消去输入字符串的全部左空格
- 使用正则表达式检测是否为合法字符串

###### 正则表达式

合法表达式需要满足如下规则

- 消去全部左空格之后，以正负号或者数字开头，下式为不符合规定的字符串，需要返回 0

$$
"words~ and~ 987"
$$

- 检测数字直到第一个不为数字的符号为止，下式返回 3

$$
3.141231231241
$$

相应的正则表达式如下

```python
p1 = r"[+-]?\d+"
pattern = re.compile(p1)
p1.match(string)
```

#### 151 Reverse Words in a String

给定一个句子，要求翻转其中单词顺序。如下
$$
"the~ sky ~is ~blue"  \rightarrow "blue~ is~ sky~ the"
$$

**解法**

- 首先对句子进行分解，使用 `string.split()` 方法，上述句子分离结果如下

$$
['the','sky','is','blue']
$$

​		其类型为列表

- 对该列表进行求逆
- 使用 " ".join() 函数进行拼接

#### 两数相加

> 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
>
> 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
>
> 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
>
> 示例：
>
> 输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
> 输出：7 -> 0 -> 8
> 原因：342 + 465 = 807

**难点：**

- 注意需要进位的情况以及在链表头添加一个 head 节点、
- 注意判断最后一次头结点相加时的进位，也就是 4 + 6 变为 0 -> 1

**解法**

- 使用两个指针，一个指针永远指向第一个没有进行旋转的数组

  - 第二个指针指向被旋转部分的数组

  - ```
    while right - left > 1
    ```

- 使用 mid 判断 mid 当前在没旋转的数组中还是被旋转的数组中

  - ```python
    while right - left > 1:
    			mid = int((left+right)/2)
    
    			if nums[mid] >= nums[right]:
    				# mid is in the first array
    				left = mid
    			else:
    				right = mid
    ```

    

注意考虑特殊情况，没有旋转的数组也算是旋转数组（旋转为 0）

```python
if nums[left] > nums[right]:
	reutrn nums[left]
```

