---
layout:     post   				    # 使用的布局（不需要改）
title:      剑指Offer(32-66) 			# 标题 
subtitle:   data structure #副标题
date:       2019-09-01 				# 时间
author:     WYX 						# 作者
header-img: img/5.11.png	                 #这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - data structure  
---

# 剑指 offer 笔记

本文长期记录剑指 Offer 刷题中需要注意的点

------

### 把数组排成最小的数

> 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。

#### 题目解法

将数字转化为字符串

- 重新定义比较规则
  - 假设当前有两个数，3 和 12
  - 首先将两个数合并，有两种可能， 312 和 123
  - 因为 312 大于 123
  - 则 12 比 3 小，12 排在 3 的前面
- 按照新的规则定义之后，将数组排序，按照排好序之后的顺序，将所有数组拼接，得到的新的数即为最小的数



### 丑数

> 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

#### 题目理解

只包含质因子2,3,5，意即只能被 2,3,5 分解至1 的数，判断如下

```python
while number%2 == 0:
	number /= 2
while number%3 == 0:
	number /= 3
while number%5 == 0:
	number /= 5
if number != 1:
	# 该数字不只包含质因子 2,3,5
```

#### 题目重点

- 不需要对每个自然整数都进行判断，为了得到下一个丑数，一定是其之前的丑数乘上 2,3,5 得到的数
- 每个已经确定的丑数都存在 3 种可能，乘上  2,3,5，得到下一个丑数，下一个丑数要取在可能的丑数中最小的
  - 如下图所示，当选取某一个数的某一个可能时（下一个丑数是该数 x2/x3/x5）,则将对应的指针向前移动，代表这个数的这个可能被选择了
  - 当遇到有相同的数时，如，丑数 2 的 x3 可能，以及 丑数 3 的 X2 可能，则同时向前移动

<center>
    <img src= "https://github.com/joseph-mutu/Pics/raw/master/uglynumbers.png" width = "800"/>
</center>

### 第一个只出现一次的数

> 在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.

#### 题目理解

利用字典，统计每一个字符在字符串中出现的次数，统计结束后，返回字典的所有 `值`，选择第一个为 1的返回，若没有，则返回 -1



### 数组中的逆序对

> 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007
>
> 示例:
>
> 输入：1,2,3,4,5,6,7,0
>
> 输出：7

#### 题目理解

利用归并排序，在每次进行两个子序列的归并的时候，统计逆序对。以


$$
[2,3,9,12,7,4,5,8,10]
$$
举例进行说明。

**第一次归并**： **length = 1**

统计时，只考虑相邻的子序列，2和3,9 和 12，7 和 4,5 和 8，以及 10

当 length 为 1 时，在 第三对子序列 {7,4} 进行排列时发现

- 左边的元素大于 右边的元素，
- 逆序对  + = 1
  - 因为左序列在原数组中也是在左侧的位置，所以左侧元素大于右侧元素，被视为逆序对
  - 逆序对统计完之后，将两个数交换，相当于消去这一逆序对

$$
\underbrace{2,3},\underbrace{9,12},\underbrace{4,7},\underbrace{5,8},\underbrace{10}
$$



**第二次归并：length = 2**

以第二对相邻子序列 $[4,7] and [5,8]$ 进行说明

- 首先扫描 4 以及 5（两个子序列的起始位置），4 < 5, 无逆序对. 将 4 放进临时数组中
- 左指针指向 7，右指针仍旧指向 5。此时 7 > 5, 左元素大于右元素，逆序对 + 1，消去当前逆序对。将 5 填入临时数组



Note: 注意归并排序本身的性质，

- **每次进行比较的两个子序列一定是有序的**，归并排序从单个的元素开始，逐渐增加 length
- 归并排序的左子序列，在原数组的位置上，相对于右子序列也是靠左的

下面以两个有序子序列说明逆序对的统计：
$$
 [\underbrace{9},12,14,15] ~~ [\underbrace{4},8,20,22]
$$

- 左指针为 9，右指针为 4
- 因为 9 > 4, 则构成逆序对。但是此时并不是将逆序对 +1,而是加上当前左子序列的长度 - 左指针位置
  - 因为，如果 9 > 4，而且左子序列有序，则 9 后面的元素均与 4 构成逆序对
  - 在归并排序中，下一步的操作是将 4 当放入临时数组，相当于忽略 4，则需要统计所有与 4 相关的逆序对

### 

### 两个链表的第一个公共节点

> 输入两个链表，找出它们的第一个公共结点。

#### 题目理解

所谓公共节点，是两个链表指向了同一个节点。因为为单向链表，如果两个链表指向同一节点，则两链表共享之后的所有节点。

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9.png" width = "800"/>
</center>



#### 题目解法

##### 自己的想法

- 遍历第一个链表，按照 `链表值` -- `链表节点地址` 的方式，存储第一个链表的每一个节点
- 遍历第二个链表，如果扫描中发现存在相同值的节点，则返回



##### 剑指offer 想法

- 遍历两个链表，并分别记录下两个链表的长度
- 将较长的链表先移动其头结点，当较长链表与较短链表长度一致时停止
- 两联链表同步扫描，如果碰到相同的节点，则返回。



### 数字在排序数组中出现的次数

> 统计一个数字在排序数组中出现的次数。

#### 自己的想法

- 利用二分，先找到数组中等于 k 的数
- 然后向左右两边扩展，左边数到第一个不是 k 的数停下，右边数到第一个不是k的数停下
- 统计一共有多少个相同的 k

##### 问题

因为要向左右两边扫描，所以当整个数组均是同一个数的时候，时间复杂度依然为 O(n)



#### 论坛中的想法

因为数组中的全为整数，利用二分法搜索 k-0.5 以及 k + 0.5 应该存在的位置，然后两个位置相减就是答案

##### 对二分法的越界进行分析

###### 当数组中存在多个 k 值

以下列数组举例说明, 

**首先搜索  2.5**


$$
[1,2,3,3,3,3,4,5,6,7,8]
$$

- start = 0, end = len(data) - 1 = 10, mid = 5, data[5] = 3 > 2.5
- start = 0, end = 4, mid = 2, data[2] = 3 > 2.5
- start = 0, end = 1, mid = 0, data[0] = 1 < 2.5
- start = 1, end = 1, mid = 1, data[1] = 2 < 2.5
- start = 2, start > end 返回 start 位置 2， 数组中第一个 3 的位置

**搜索3.5**

- start = 0, end  = 10, mid = 5, data[5] = 3 < 3.5
- start = 6, end = 10, mid = 8, data[8] = 6 > 3.5
- start = 6, end = 7, mid = 6, data[6] = 4 > 3.5
- start = 6,end = 6, mid = 6, data[6] = 4 > 3.5
- start = 6, end = 5 , 结束，返回 start 位置 6，数组中第一个大于 3 的位置

###### 当数组中全为 3

以下列数组举例


$$
[3,3,3,3,3]
$$
**搜索 2.5**

- start  = 0, end = 4,mid = 2 ,data[2] = 3 > 2.5
- start = 0, end = 1, mid = 0, data[0] = 3 >2.5
- start = 0, end = 0, mid = 0 ,data[0] = 3 > 2.5
- start = 0 ,end = -1, 结束 返回 start , 位置 0，第一个 3 的位置

**搜索 3.5**

- start = 0,end = 4, mid = 2, data[2] = 3 > 2,5
- start = 3, end = 4, mid = 3,data [3] = 3 > 2.5
- start = 4, end = 4, mid = 4, data[4] = 3 > 2.5
- start = 5, end = 4，结束，返回 start ，第一个大于 3 的位置**(越界)**



Note：

- 搜索 小于 3 而数组中不存在的值，总会返回 第一个 3 的位置
- 搜索大于 3 而数组中不存在的值，会返回第一个大于 3 的位置