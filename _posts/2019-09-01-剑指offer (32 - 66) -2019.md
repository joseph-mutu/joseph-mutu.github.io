---
layout:     post   				    # 使用的布局（不需要改）
title:      剑指Offer(32-66) 			# 标题 
subtitle:   data structure #副标题
date:       2019-09-01 				# 时间
author:     WYX 						# 作者
header-img: img/5.11.png	                 #这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - data structure  
---

# 剑指 offer 笔记

本文长期记录剑指 Offer 刷题中需要注意的点

------

### 把数组排成最小的数

> 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。

#### 题目解法

将数字转化为字符串

- 重新定义比较规则
  - 假设当前有两个数，3 和 12
  - 首先将两个数合并，有两种可能， 312 和 123
  - 因为 312 大于 123
  - 则 12 比 3 小，12 排在 3 的前面
- 按照新的规则定义之后，将数组排序，按照排好序之后的顺序，将所有数组拼接，得到的新的数即为最小的数



### 丑数

> 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

#### 题目理解

只包含质因子2,3,5，意即只能被 2,3,5 分解至1 的数，判断如下

```python
while number%2 == 0:
	number /= 2
while number%3 == 0:
	number /= 3
while number%5 == 0:
	number /= 5
if number != 1:
	# 该数字不只包含质因子 2,3,5
```

#### 题目重点

- 不需要对每个自然整数都进行判断，为了得到下一个丑数，一定是其之前的丑数乘上 2,3,5 得到的数
- 每个已经确定的丑数都存在 3 种可能，乘上  2,3,5，得到下一个丑数，下一个丑数要取在可能的丑数中最小的
  - 如下图所示，当选取某一个数的某一个可能时（下一个丑数是该数 x2/x3/x5）,则将对应的指针向前移动，代表这个数的这个可能被选择了
  - 当遇到有相同的数时，如，丑数 2 的 x3 可能，以及 丑数 3 的 X2 可能，则同时向前移动

<center>
    <img src= "https://github.com/joseph-mutu/Pics/raw/master/uglynumbers.png" width = "800"/>
</center>

### 第一个只出现一次的数

> 在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.

#### 题目理解

利用字典，统计每一个字符在字符串中出现的次数，统计结束后，返回字典的所有 `值`，选择第一个为 1的返回，若没有，则返回 -1



### 数组中的逆序对

> 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007
>
> 示例:
>
> 输入：1,2,3,4,5,6,7,0
>
> 输出：7

#### 题目理解

利用归并排序，在每次进行两个子序列的归并的时候，统计逆序对。以


$$
[2,3,9,12,7,4,5,8,10]
$$
举例进行说明。

**第一次归并**： **length = 1**

统计时，只考虑相邻的子序列，2和3,9 和 12，7 和 4,5 和 8，以及 10

当 length 为 1 时，在 第三对子序列 {7,4} 进行排列时发现

- 左边的元素大于 右边的元素，
- 逆序对  + = 1
  - 因为左序列在原数组中也是在左侧的位置，所以左侧元素大于右侧元素，被视为逆序对
  - 逆序对统计完之后，将两个数交换，相当于消去这一逆序对

$$
\underbrace{2,3},\underbrace{9,12},\underbrace{4,7},\underbrace{5,8},\underbrace{10}
$$



**第二次归并：length = 2**

以第二对相邻子序列 $[4,7] and [5,8]$ 进行说明

- 首先扫描 4 以及 5（两个子序列的起始位置），4 < 5, 无逆序对. 将 4 放进临时数组中
- 左指针指向 7，右指针仍旧指向 5。此时 7 > 5, 左元素大于右元素，逆序对 + 1，消去当前逆序对。将 5 填入临时数组



Note: 注意归并排序本身的性质，

- **每次进行比较的两个子序列一定是有序的**，归并排序从单个的元素开始，逐渐增加 length
- 归并排序的左子序列，在原数组的位置上，相对于右子序列也是靠左的

下面以两个有序子序列说明逆序对的统计：
$$
 [\underbrace{9},12,14,15] ~~ [\underbrace{4},8,20,22]
$$

- 左指针为 9，右指针为 4
- 因为 9 > 4, 则构成逆序对。但是此时并不是将逆序对 +1,而是加上当前左子序列的长度 - 左指针位置
  - 因为，如果 9 > 4，而且左子序列有序，则 9 后面的元素均与 4 构成逆序对
  - 在归并排序中，下一步的操作是将 4 当放入临时数组，相当于忽略 4，则需要统计所有与 4 相关的逆序对

### 

### 两个链表的第一个公共节点

> 输入两个链表，找出它们的第一个公共结点。

#### 题目理解

所谓公共节点，是两个链表指向了同一个节点。因为为单向链表，如果两个链表指向同一节点，则两链表共享之后的所有节点。

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9.png" width = "800"/>
</center>



#### 题目解法

##### 自己的想法

- 遍历第一个链表，按照 `链表值` -- `链表节点地址` 的方式，存储第一个链表的每一个节点
- 遍历第二个链表，如果扫描中发现存在相同值的节点，则返回



##### 剑指offer 想法

- 遍历两个链表，并分别记录下两个链表的长度
- 将较长的链表先移动其头结点，当较长链表与较短链表长度一致时停止
- 两联链表同步扫描，如果碰到相同的节点，则返回。



### 数字在排序数组中出现的次数

> 统计一个数字在排序数组中出现的次数。

#### 自己的想法

- 利用二分，先找到数组中等于 k 的数
- 然后向左右两边扩展，左边数到第一个不是 k 的数停下，右边数到第一个不是k的数停下
- 统计一共有多少个相同的 k

##### 问题

因为要向左右两边扫描，所以当整个数组均是同一个数的时候，时间复杂度依然为 O(n)



#### 论坛中的想法

因为数组中的全为整数，利用二分法搜索 k-0.5 以及 k + 0.5 应该存在的位置，然后两个位置相减就是答案

##### 对二分法的越界进行分析

###### 当数组中存在多个 k 值

以下列数组举例说明, 

**首先搜索  2.5**


$$
[1,2,3,3,3,3,4,5,6,7,8]
$$

- start = 0, end = len(data) - 1 = 10, mid = 5, data[5] = 3 > 2.5
- start = 0, end = 4, mid = 2, data[2] = 3 > 2.5
- start = 0, end = 1, mid = 0, data[0] = 1 < 2.5
- start = 1, end = 1, mid = 1, data[1] = 2 < 2.5
- start = 2, start > end 返回 start 位置 2， 数组中第一个 3 的位置

**搜索3.5**

- start = 0, end  = 10, mid = 5, data[5] = 3 < 3.5
- start = 6, end = 10, mid = 8, data[8] = 6 > 3.5
- start = 6, end = 7, mid = 6, data[6] = 4 > 3.5
- start = 6,end = 6, mid = 6, data[6] = 4 > 3.5
- start = 6, end = 5 , 结束，返回 start 位置 6，数组中第一个大于 3 的位置

###### 当数组中全为 3

以下列数组举例


$$
[3,3,3,3,3]
$$
**搜索 2.5**

- start  = 0, end = 4,mid = 2 ,data[2] = 3 > 2.5
- start = 0, end = 1, mid = 0, data[0] = 3 >2.5
- start = 0, end = 0, mid = 0 ,data[0] = 3 > 2.5
- start = 0 ,end = -1, 结束 返回 start , 位置 0，第一个 3 的位置

**搜索 3.5**

- start = 0,end = 4, mid = 2, data[2] = 3 > 2,5
- start = 3, end = 4, mid = 3,data [3] = 3 > 2.5
- start = 4, end = 4, mid = 4, data[4] = 3 > 2.5
- start = 5, end = 4，结束，返回 start ，第一个大于 3 的位置**(越界)**



Note：

- 搜索 小于 3 而数组中不存在的值，总会返回 第一个 3 的位置
- 搜索大于 3 而数组中不存在的值，会返回第一个大于 3 的位置



### 二叉树的深度

> 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。

#### 题目解法

进行递归，求解树的深度

需要注意的是，可以从尾部进行递归，每次 + 1

```python
def get_height(self,pRoot):
	if pRoot is not None:
		return max(self.get_height(pRoot.left),self.get_height(pRoot.right)) +1
	else:
		return 0
```

上述代码，

- 在到达根节点时，比如说 1，继续进行 `self.get_height(pRoot.left)` `self.get_height(pRoot.right)` 得到两个 0 值，然后 本身深度 + 1，则 1 节点为深度 1 

- 将 1 的深度赋值给 3.left = 1, 同样 3.right = 1, 向上传递时当前深度 + 1

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.png" width = "800"/>
</center>



### 平衡二叉树

> 输入一棵二叉树，判断该二叉树是否是平衡二叉树。

<center>
    <img src= "https://github.com/joseph-mutu/Pics/raw/master/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%A4%E5%AE%9A.jpg" width = "800"/>
</center>

#### 自己的想法

- 将所有节点依次遍历，每个节点都求当前节点的左右子树的高度差
- 如果高度差 > 1，则 `return False`

##### 问题

会对子树进行多次遍历

#### 论坛想法

从底层遍历，如果当前某一个节点的左右子树的高度差超过 1，则直接返回 False。以上图中间的二叉树举例

- 将根节点 6 传入，要求 6 的左右子树的高度差，需要对 4 和 8 进行遍历
- 求 4 的深度，需要进行 1 和 5
- 求 8 的深度，需要求 9 
- 在某一层发现某一个节点不满足平衡二叉树的条件时，直接一路返回





### 数组中只出现一次的数字

> 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

#### 自己的想法

- 利用字典，从第一个数字开始，`键` 为数字的值，`值`为数字出现的次数

- 当数字再次出现的时候，将该`键`  `值` 删除

  - 如何判断数字再次出现

  - ```python 
    if dic[num] in dic:
    	del dic[num]
    ```



### 异或方法

<u>一组数字均成对出现，只有一个数单独出现，此时对这个数组从 data[0] 的位置开始进行异或，最后剩下的就是这个单独出现的数字</u>

#### 异或

**参与运算的两个值，如果其相应二进制位相同，异或结果为 0，相应二进制为不同，异或结果为 1**

如 3 的二进制为 11，2 的二进制为 10，4 的二进制位为 100

下面以下列数组进行异或方法的说明


$$
[3,4,3,2,4]
$$

- 从第一位开始进行异或，则最终的结果为数组中仅出现一次的 2
- 

$$
3:011~~~~~~~~~~~~~~7:111~~~~~~~~4:100~~~~~~~~6:110\\
4:100~~~\Rightarrow~~~~~3:011~~~~~~~~2:010~~~~~~~~4:100\\
-------------------\\
7:111~~~~~~~~~~~~~~4:100~~~~~~~~6:110~~~~~~~~2:010
$$



### 和为 S 的连续正数序列

> 输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序

#### 题目方法

以目标为 15 举例

- 定义一个 start = 1，end = 2，当前序列 start ~ end 之和为 3
- 如果当前和 > 目标值，说明当前的序列和大，所以要进行缩小
  - 缩小时从 start 开始缩小，因为 start 是最小的值，也就是 start 向前移动，并更新 curSum
- 如果当前和 < 目标值，说明当前的序列和需要进行扩大，则 end 向下移动一位，并更新 curSum
- 如果当前和 == 目标值，则对当前序列进行添加
  - 注意，**序列和添加时需要判断**，`end - start > 1`，否则 15 这个单个数也会被添加进序列
- 往复循环，**大于** int(target/2) + 1
  - int(target/2) + 1 这个数是最后一个可能的数字，因为题目要求必须要连续的两个数字，则从 1 ~ 15 中间的那个数字就是最后一个可能的连续数字。中间数之后的数均大于中间数，且两者之和肯定大于 15
  - int(15/2) + 1= 8

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%95%B0%E5%AD%97.png" width = "800"/>
</center>



### 排序数组中和为 S 的数字

> 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。

#### 题目理解

- 定义一个 start 一个 end，start 为数组为 0 的位置，end 为数组最后一个数字
  - 数组最后一个数字最大，要搜索所有可能，自然要从数组最小的数字开始
- 如果当前两个数字的和大于 target ，则需要减小当前数值，将 end 向前移动一位
- 如果当前两个数字的和小于 target，则需要增加当前的数值，则将 start 向后移动一位
- 如果当前两个数字的和等于 target，则判断当前两个数字的乘积是否大于当前的最大乘积
  - 如果小于，则更新输出的两个数，并将 start + 1
  - 如果等于，则直接 start + 1



### 左旋转字符串

> 对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”

#### 自己的解法

- 将字符串列表化

- 每次将第一个字符先添加到列表尾部
- 删除第一个字符

#### 剑指offer解法

- 设定一个翻转函数
  - 实现的功能为：给定 start 和  end，翻转 start 和 end 之间所有的字符
  - 实现方法：start 在字符串头部，end 在字符串尾部，每次交换 start 和 end
    - start += 1， end -= 1
    - 终止条件为 start >= end
- 要完成上述前 k 个字符串左旋，需要进行三次翻转
  - 前 k 个字符定义为 X，字符串剩下字符定义为 Y
  - 则 YX = $(X^TY^T)^T$ , 意即先将前 k 个字符串翻转，再将后 Y 个字符串翻转，最后整体翻转



### 翻转单词顺序列

> 例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。

#### 题目解法

利用上一题的 Reverse 函数

- 先将单词整体翻转
- 将单词按照空格分隔
- 将每个单词再次进行翻转

#### 出现的问题

问题出在 Python 的 `string.split(" ") `函数

如果输入一个空格字符串 “ ”，则 `string.split(" ")` 会返回一个列表，里面两个空元素 ['','']

##### 解决方法

利用 Python 的 set函数，先对字符串进行判断，如果字符串 `len(list(set(string))) == 1` 并且 `list(set(string))[0] == " "` 则表示输入字符串全为空格，则直接进行返回

### 扑克牌顺子

> LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)...他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子.....LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。



#### 题目理解

看 5 张牌是否连续，且大小王视为特殊数字，可以填补任何空缺

- 填补空缺，意即相邻两张牌的差值大于1时，大小王可以填补 1
  - 比如，3 和 5，中间差值为 2，大小王可以填补一个差值变为 345
  - 但是这项统计必须在数组排序的情况下进行

则需要进行以下工作：

- 将数组排序
- 扫描数组
  - 统计 0 的个数
  - 统计**非 0 元素**之间的差值
- 如果 0 元素的个数大于非 0 元素的差值，则可以成为顺子
- 如果数组出现多个相同数字，则返回 False



### 孩子们的游戏（约瑟夫圆环问题）

> 给定 人数 n（编号从 0 ~n-1），以及数字 m。从 0 开始报数，数到 m - 1的人被淘汰。此时从 被淘汰的人的下一个人开始从新编号，继续报数，淘汰，直到只剩下一个人为止，求这个人的编号为多少

#### 题目理解

如下图所示，每次淘汰一个人之后，从下一个人开始从新计数，成为一个新的圆环问题

注意一点，每次淘汰一个人之后，成为新的圆环，它们的`解` 不变，并且可以预见的是，最小的圆环为一个人，解在最小的圆环中编号为 0，如果能够找到与之相对应的上一个圆环的对应位置的编号，不断向前追溯，就可以找到在第一个圆环中其相应的编号，也就是答案

注意，推导过程为：每次从**当前圆环**推导**上一圆环**的对应位置编号

以下图为例说明，从第二个圆环（第二列）推导第一个环的对应编号

- 0 + 3 = 3 % 6 = 3
- 1 +3 = 4 % 6 = 4
- 2 + 3 = 5 % 6 = 5
- 3 + 3 = 6 % 6 =0
- 4 + 3 = 7 % 6 = 1



<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/joseph%20circle.png" width = "800"/>
</center>

当 m > n 的情况让我困惑了一阵，但是从规律来看，和 m < n 情况相同

- 0 + 9 = 9 % 6 = 3
- 1 + 9 = 10 % 6 = 4
- 2 + 9 = 11 % 6 =5
- 3 + 9 = 12 % 6 =0
- 4 + 9 = 13 % 6 = 1

则从可以肯定的最后一个圆环的 0 一直向上追溯，可以追溯会其最初的位置



### 求1+2+3+...+n

> 求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

#### 题目想法

利用逻辑短路的方法。

##### 逻辑短路

在 Python 中的判断 `and` 和 ` or`

在 and 判断中

```python
return a and b
```

如果 a 为假，则直接会返回 a 比如

```python
return 0 and 1
```

会返回 0

在 or 判断中

```python
return a or b
```

如果 a 为真，则直接会返回 a

比如

```python
return 1 or 0
```

则会返回 1

```python
return 0 or 1
```

则也会返回 1





### 不用加减乘除做加法

> 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。

#### 题目理解

利用位运算模拟加法运算，计算如下

- 将数字使用二进制表示（正数以及负数都使用补码进行表示，正数的补码就是其本身的二进制码），将第一个数字记为` num1 `, 第二个数字记为` num2  `

- 计算 ` num1 ` 和 ` num2 ` 二进制码互加，但不进位

  - $$
    00101\\
    10001 \\
    -----\\
    10100
    $$

  - 这一操作可以利用 `num1`  ^ `num2` 进行模拟

-  `num1` 和 `num2` 的进位表示

  - $$
    00101\\
    10001\\
    -----\\
    00010
    $$

  - 上式只有倒数第二位进位，其他位置皆为 0

  - 这一操作，可以用 （num1 & num2） << 1进行模拟

    - 先对两个数进行位与操作，再左移

- 将第一步不进位的结果赋予 `num1`

- 重复第一步，num1 = `num1` ^ `num2`相加不进位

- 直到进位表示为 0 结束



#### Python 中存在的问题

Python 计算负数进位的时候不会溢出。其他语言在计算负数进位的时候，到达 $2^{32}$ 时，会溢出成为 0，但是 python 数值可以无限大

```python
class Solution:
	def Add(self, num1, num2):
		while num2 != 0: 
			sum_without_carry = (num1^num2) & 0xffffffff
			num2 = (num1 & num2) << 1 
			num1 = sum_without_carry 
		return num1 if num1 >> 31 == 0 else num1 - 4294967296
```

上述程序在 return 时候判断 `if  num1 >>31 == 0` 为检测当前值是否为正数，如果为正数直接返回。（正数右移 31 位一定为 0，32 位系统下范围为 [$2^{32}, 2^{31}-1$]）





### 把字符串转换成整数

> 将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。
>
> ## 输入描述:
>
> ```
> 输入一个字符串,包括数字字母符号,可以为空
> ```
>
> ## 输出描述:
>
> ```
> 如果是合法的数值表达则返回该数字，否则返回0
> ```



#### 题目理解

- 将字符数字转为 int 类型，如果有非字符数字型的字符出现，则直接返回 0
- 在输入字符串的开头，会有 `+` 和 `-` 表示输入的正负号，如果没有正负号表示则默认按照 `+` 处理

#### 题目解法

- 建立一个合法的数组，数组中存有 `['1','2','3','4','5','6','7','8','9','+','-']`

- 首先判断字符串首，如果存在正负号表示，则将 `Pos_Neg` 符号按照相应的正负号设置成  +1 或者 -1

  - 如果字符串首没有正负号，则返回默认的 `Pos_Neg` 符号为 +1 

- 扫描剩余字符串，如果存在非法字符 如 `‘l’` 或者 `'a'` 等字符，直接返回 0

  - 如果为 合法字符则

  - ```python
    sum = sum*10 + legal_dic.index(str)
    ```

  - 每次将 sum *10 代表将新的数字添加到新位置上。sum 初始为 0，若输入字符串的第一位为 2，则 sum = 0 * 10 + 2 = 2





### 数组中重复的数字

> 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。

#### 自己的想法

- 建立一个字典，其中 `键` 为数字，`值` 为数字出现的次数
- 从头到尾扫描数组，如果当前数字存在于字典当中，则直接返回
- 如果扫描完成后，返回 False



#### 剑指offer 的解法

因为数组的数字全部在  0 ~ n-1 的范围之内，所以利用这一范围，当前数字就存在于数字值的这个位置。比如，0 就在 0 这个位置，2 在数组中就在 2 这个位置

- 开始扫描数组，如果当前数字与当前位置相匹配，则向前进

- 否则，进行交换。将当前数字与其位置上所在的数字进行交换

  - $$
    [2,3,1,4,0]
    $$

  - 以上述举例，第一位为 2， 2 应该在数组中的 `2` 位置，则进行交换。交换之后为

  - $$
    [1,2,3,4,0]
    $$

  - 继续查看当前数字是否与当前位置匹配，如果不匹配，继续与其匹配位置交换

- 如果在交换的过程中发现，要交换的位置与当前交换的数字一致，则说明数字中有重复的值

以下列举例子
$$
[2,3,1,0,2,5,3]
$$

- 当前位置为0，当前位置元素为 2，不匹配，进行交换

  - $$
    [1,3,2,0,2,5,3]
    $$

- 当前位置仍旧为  0，当前位置元素为 2，不匹配，进行交换

  - $$
    [3,1,2,0,2,5,3]
    $$

- 当前位置为 3，当前位置元素为 3，不匹配，交换

  - $$
    [0,1,2,3,2,5,3]
    $$

- 当前位置为 0，当前元素为 0，匹配，前进

- 当前位置为 1，当前元素为 1，匹配，前进

- 当前位置为 2，当前元素为 2，匹配，前进

- 当前位置为 3，当前元素为 3，匹配，前进

- 当前位置为 4，当前元素为 2，不匹配，交换

  - 交换位置元素与待交换元素一致，元素重复，返回





### 构建乘积数组

> 给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。

#### 自己的想法

并没有好的想法，只想到利用直观解法



#### 剑指 offer 解法

- 将 B 矩阵视为由左右两个数组的乘积
- 一个矩阵从顶向下进行构建，一个矩阵从底向上进行构建
- 最后两个数组相乘得到 B 矩阵

<center>
    <img src ="https://github.com/joseph-mutu/Pics/raw/master/%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84.jpg" width = "500"/>
</center>



### 正则表达式匹配

> 请实现一个函数用来匹配包括 '.' 和 '*' 的正则表达式。模式中的字符 ' . ' 表示任意一个字符，而 * 表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但是与"aa.a"和"ab*a"均不匹配

#### 题目解法

分情况进行递归

- 如果当前字符串 s[0] 和模式字符串中 pattern[0] 相等
  - 则当前字符串匹配成功，进行下一字符的匹配，`self.match(s[1:],pattern[1:])`
- 如果当前字符串 s[0] 与模式字符串中的 pattern[0] 不相等，但 pattern[0] = "."
  - 因为 “.” 可以表示任意字符串，则继续进行下一字符的匹配，`self.match(s[1:],pattern[1:])`
- 如果模式字符串中的 pattern[1] 的位置 pattern[1] == "*" ，则说明出现星号匹配模式
  - 如果当前 s[0] != pattern[0]，因为星号，则直接跳过 pattern 当前的字符，进行下一字符的匹配 `self.match(s,pattern[2:])`
  - 如果当前 s[0] == pattern[0]，则分情况
    - 进行匹配 `self.match(s[1:],pattern)`
    - 不进行匹配 `self.match(s,pattern[2:])`

##### 停止条件

- 当 s 字符串为空，且模式字符串也为空时，为 `True`
- 当 s 字符串不为空，但模式字符串为空时，为 `False`
- 当 s 字符串为空，但是模式字符串不为空时
  - 如果模式字符串的最后两个值为 `x*` 则为 `True`
  - 否则则为 `False`

#### 字符串是否为空的判定

假设当前字符串为 `a = 'a'` ，则 

```python
a[1:]
```

得到的不是一个 None，而是一个空字符串，即 len (a[1:]) == 0