---
layout:     post   				    # 使用的布局（不需要改）
title:      剑指Offer(长期) 				# 标题 
subtitle:   data structure          #副标题
date:       2019-07-05 				# 时间
author:     WYX 						# 作者
header-img: img/5.1.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - data structure  

---



# 剑指 offer 笔记

本文长期记录剑指 Offer 刷题中需要注意的点

---

### 二维数组中的查找

> 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数

#### **自己的想法**

用二分法搜索每一行。如果一行的第一个值大于想要的数字，则退出。先判定数组是否为空，为空的话返回 False

**注意**：系统输入的是一个二维的空列表，判定大小要注意

```
array = [[]]
# 使用 len 判定数组是否为空有问题,len(array) 输入为1
```

#### 讨论中的想法：

从左下开始搜索，如果当前数据大于 want_num 则向上移动一位；如果当前数据小于 want_num 则向右移动一位；梯度上升



### 替换空格

> 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

#### 自己的想法

使用python 内置函数 replace 直接进行替换

```python
a = 'asd2 qweasda'
a = a.replace(' ','%20')
```

#### 讨论（可以查看在线解析）

- 首先扫描字符串中一共有多少个空格
- 在字符串后面添加 2 * num_space 的任意字符
- 使用两个变量分别记录真正的字符串的最后一位以及添加字符串的最后一位
- 两个变量同时向前移动
  - 如果真正的字符串当前指的不是空格，则将当前指的值赋值给添加字符串当前的位置
  - 如果真正的字符串当前指的是空格，则将添加字符串位置向前移动三位，并在移动过程中添加 “%20”

![替换空格](https://ae01.alicdn.com/kf/HTB1F9JtXxv1gK0jSZFF7620sXXaa.png)

在增加字符串长度的过程中，首先将字符串转为了 list，然后在list后面添加

```python
string = list(s)		
string2 = ['0' for i in range(num_space*2)]
string += string2
```



### 从尾到头打印列表

> 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。

#### 自己的想法

- 将链表每一个值从头到尾储存在一个列表中
- 将列表翻转. 
  - list.reverse()
- 打印列表

#### 讨论

进行递归调用

终止条件为：

- 当列表当前值为 None 时，表示当前访问 Node 为最后一个值的下一个值。则返回空列表 []

```python
 if listNode is None:
        	return []
        else:
        	return self.printListFromTailToHead(listNode.next) + [listNode.val]
```



### 重建二叉树

> 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

#### 自己的想法

递归求解

以下图的二叉树为例

 <center>
    <img src="https://github.com/joseph-mutu/Pics/raw/master/reconstruct binary trees(jianzhi).jpg" width="200"/>
</center>

根据前序以及中序遍历的结果，可以恢复二叉树。

- 前序遍历的结果中，首位的数是**当前**二叉树的**根节点**
- 根据当前二叉树的根节点，在中序遍历结果中，根据当前子树的length，查找其左右子树
  - 如，初始情况下，当前二叉树的根节点为 1
  - 在 in 列表中定位 1，当前二叉树的 length 为 6。1 在 in 列表中的位置为 3（从 0 开始）。则其左子树长度为 3（左子树中存在 3 个元素）。右子树的长度的 “当前二叉树长度 - 左子树长度 - 1 ”
- 递归求解左子树以及右子树。将左子树视为当前二叉树。移动 pre 列表中的首位元素（根据左子树长度以及右子树长度进行分别移动到左右子树的根节点）。
- 对于当前左子树来说，根节点为  2。对于当前右子树来说，根节点为 5
  - 求解左子树
    - 左子树长度为 3。则当前二叉树长度为 3。在 in 数组中定位到其根节点 2，索引为 1。则左子树的左子树长度为 1 - 0 = 1。左子树的右子树长度为 3 - 1 -1 = 1。
  - 求解右子树
    - 右子树长度为 2。则当前二叉树长度为 2。在 in 数组中定位其根节点 5，索引为 5。则右子树的左子树长度为 5 - 4 = 1。右子树的右子树长度为 2 - 1 - 1=0
      - 注意对于右子树来说，in 数组的起始索引为 4。

##### 递归终止条件

由上述描述可知，两种情况

- 子树长度为 1。则当前传入节点为叶节点。即 cur_node.left = None. cur_node.right = None
- 子树长度为 0。当前传入节点无叶节点。直接返回



### 用两个栈模拟队列

> 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

#### 想法



<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E4%B8%A4%E4%B8%AA%E6%A0%88%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97.png" width ="400"/>
</center>





分为 Push 操作和 pop 操作，模拟的是队列的先进先出原则

- Push 操作将每一个元素按照栈的操作先压到第一个栈中。如上图第一个栈的 A,B,C,D
- Pop 操作首先判断第二个栈是否为空
  - 如果为空，将第一个栈的所有元素按照 pop 的顺序压到第二个栈中。此时顺序调换
    - 如D,C,B,A 此时被压到第二个栈中
    - Pop 第二个栈的元素。模拟先进先出
  - 如果不为空，则 return 第二个栈的pop元素





### 旋转数组里的最小数字

> 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
> NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

##### 题目理解

原数组为一个**非递减**数组。但是输入数组为经过旋转之后的数组。此题只考虑旋转一次或者没有旋转的情况。

- 非递减意味着，数组中可能存在重复的元素。即[1,1,0,1,1] 这样的数组也存在于输入中





<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.jpg" width = "300"/>
</center>



- 原数组在进行旋转之后，输入数组可以分为两部分。**且两部分顺序皆为非递减排序**。**且第一部分元素皆大于等于第二部分元素**。即上述白色以及灰色部分
  - 旋转数组的最小值在旋转数组两部分的分界处。即要找到原数组的第一个值



##### 题目解法

使用二分法。但是每次要保证两个指针不会彼此错位。即第一个指针要始终在第一部分移动(白色)，第二个指针始终在第二部分移动（灰色）。

###### 如何保证指针彼此不错位

P1 初始位置指向输入数组的第一个值。P2 初始位置在输入数组的最后一个值。

- 首先选取中间值。 mid = (int) (P1 + P2)/2
- 中间值有两个可能。在白色区域，或者在灰色区域。
  - 在白色区域，则中间值比 P1 此刻的值大（相等）。
    - 将 P1 指向中间值所在的位置
  - 在灰色区域，则中间值比 P2 此刻的值小（相等）。
    - 将 P2 指向中间值所在的位置



但是上述解法没有考虑到特殊情况。（原数组为**非递减数组**）



###### 题目特例

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%EF%BC%88%E7%89%B9%E4%BE%8B%EF%BC%89.jpg" width = "600"/>
</center>

- 如果中间值与 P1 和 P2 值完全相等。则无法判断中间值处于哪一个区域。则只能用顺序查找进行
- 第二种特例。如果在开始的时候，P1 的值就小于 P2 的值。则数组没有旋转。直接输出 P1



### 青蛙跳台阶以及变态跳台阶

#### 青蛙跳台阶

> 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

##### 题目理解

斐波那契数列的应用。从只有一级台阶分析

- 1 级台阶。只有一种跳法。f(1) = 1
- 2 级台阶。有 2 种跳法。1 + 1/2。f(2) = 2
- 3 级台阶。可以从  1 级台阶跳到 3 级 / 从 2 级台阶跳到 3 级。所以 f(3) = f(1) + f(2)
  - 注意从 1 级到 3 级只有一种跳法 1 + 2。从 1 级先到 2 级再到 3 级这种情况已经被 f(2) 囊括在内（1+1+1）





#### 变态跳台阶

> 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

题目理解

从只有一级台阶分析

- 1级台阶。一种跳法
- 2 级台阶。2 种跳法。从 0 到 2/ 从  1到 2
- 3 级台阶。0 -> 3 / 1->3 / 2->3 = f(0) + f(1) + f(2)。因为无论几级台阶都能直接跳。则设定  f(0) =  1
- 4 级台阶。f(0) + f(1) + f(2) + f(3)
- ...

假设求 f(4) = f(0) + f(1) + f(2) + f(3)，有

- 因为 f(3) = f(0) + f(1) + f(2)
- 则 f(4) = 2*f(3)

以此类推

- f(n) = 2*f(n-1)



### 矩形覆盖

> 我们可以用2 * 1的小矩形横着或者竖着去覆盖更大的矩形。请问用 n个 2 * 1的小矩形无重叠地覆盖一个2 * n的大矩形，总共有多少种方法？

#### 题目理解

从只有一个矩形来看。

- 当矩形只有一个时，显然，只有一种方法覆盖
- 当矩形存在两个时。存在两种方法。一种竖着一种横着。**注意**，矩形的顺序无影响。

<center>
    <img src ="https://github.com/joseph-mutu/Pics/raw/master/%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%961.png" width = "500"/>
</center>

- 当矩形的存在为 3 个时，如下图所示。因为增加了一个小矩形，就增添了一种横着放的可能（下图，从 f(1) 到 f(3)）。

  <center>
      <img src= "https://github.com/joseph-mutu/Pics/raw/master/%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%962.png" width = "500"/>
  </center>

  

由以上可以得出，矩形覆盖 f (n) 依赖于其前两个状态 f(n-1) f(n-2)



### 二进制中 1 的个数

> 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

#### 题目理解

##### 原码，反码以及补码表示

8 的二进制**原码**表示为：


$$
1000: 0 \times 2^0 + 0 \times 2^1 + 0 \times 2^2 + 1 \times 2^3
$$


所谓反码即为将原码中 **1** 与 **0** 互换，如上述 8 的反码为：


$$
1000 \Rightarrow_{反码} 0111
$$


在 32进制中，数字使用补码来表示负数。所谓补码，即反码 + 1。且最高位为符号位（0 表示正数，1 表示负数。符号位在变为反码的过程中不变化）。下述为 -1 的反码表示。


$$
原码:~ 1(符号位)000 ~ 0000 ~ 0000 ~ 0000 ~ 0000 ~ 0000 ~ 0000 ~ 0001
$$

$$
反码：~1(符号位)111 ~1111 ~1111 ~1111 ~1111 ~1111 ~1111 ~1110
$$

$$
补码（反码 + 1）~ : ~1(符号位)\underbrace{111 ~1111 ~1111 ~1111 ~1111 ~1111 ~1111 ~1111}_{序号位}
$$

##### 一般情况下如何求 1 的个数（针对正数）

以 12 举例，在 32 位的情况下，12 的二进制原码表示如下：


$$
0000 ~ 0000 ~ 0000 ~ 0000 ~ 0000 ~ 0000 ~ 1100
$$


现在将 12 减去 1，为 11 ，观察 11 的二进制码


$$
1100 \Rightarrow 1011 : 1 \times 2^0 + 1 \times 2^1 + 0 \times 2^2 + 1 \times 2^3 = 11
$$
观察得到，将一个数，减去1之后所得到的二进制码**只改变原数**二进制原码，**最右边**的1，并将最右边的1之后的 0 取反。

则，若将 12-1 与 12 再次进行位与运算，如下


$$
\begin{equation}
位与 \left\{
\begin{aligned}
& 1001 \\
& 1100 \\
\end{aligned}
\right.
\end{equation}

\Rightarrow 1000
$$


则次操作可以视为，消去最右边一个 1。重复此操作，直至最后结果为 0 为止。



**Note:**

在 python 中，负数 不可使用上述的方法，会陷入循环。因为python 中不使用补码的形式表示负数。

##### 解决方法

```python
n = n if n > 0 else n & 0xFFFFFFFF
```

将 -1 & 0xFFFFFFFF, 可以将 -1 的补码形式转换成一个无符号数，也就是其补码形式相对应的正数。从而再进行操作。



### 数值的整数次方

> 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。

#### 题目理解

1. 拿到题目首先要确定题目的特例
   1. 任何数的 0 次幂为 1
   2. 0 的任除1外的任何次幂皆为 0 
   3. 负数次幂为其正数次幂的倒数
      1. 注意特例， 0/任何数 无意义



#### 题目解法

使用快速幂，而不是如下所示每次叠加一次

##### 低效率

```python
for i in range(numExponent):
    base *=base
return base
```



##### 快速幂分析

任何整数均可以表示为二进制形式，如 12 的二进制形式如下：


$$
1100 : ~ 0 \times 2^0  + 0 \times 2^0 + 1\times 2^2 + 1 \times 2^3
$$


则如果要求 $2^{12}$ , 则可以将其分解为如下形式：


$$
2^{12} = 2^{0 \times 2^0  + 0 \times 2^0 + 1\times 2^2 + 1 \times 2^3} \\
\space  \\
=2^{0 \times 2^0} * 2^{0 \times 2^0} *2^{1\times 2^2 } *2^{1 \times 2^3}
$$


note：在上述形式中，只有当当前的二进制码为 1 的时候，才进行相乘。则算法的想法为：

- 从右边的第一个二进制码开始，如果当前的二进制码为  1 ，则与当前的 curBase 相乘
- 如果当前的二进制码为 0，则只累计 curBase
- 将当前的 exponent 移位
  - 以 12 举例。其当前的二进制表示为 1100。
  - 此时判断其二进制表示的最后一位是否为 1
  - 将 12 向右移动一位
    - 0110： $2^0 \times 0 + 2^1 \times 1 + 2^2 \times 2 = 6$
  - 循环判断，当 exponent 移位至 0 时，结束判断

```python
while exponent:
    if exponent & 1:
        ans *= curBase
        curBase *= curBase
    exponent >>= 1
```

##### 技巧

- 使用左移右移代替乘法除法

  - 左移为乘法

  - 右移为除法

    - ```python
      3<<1
      输出为：1，相当于 int(3/2)
      ```





### 调整数组的顺序，使奇数位于偶数前面

> 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

#### 题目解法

以如下数组举例


$$
[2,3,4,0,5,6]
$$

- 从头开始判断。以 temCount 记录操作的次数。当操作的次数与原数组长度相同时，结束

- 如果当前的位置元素为偶数，则将当前元素添加到数组的尾端，并从原数组中删除该元素

  
  $$
  [3,4,0,5,6,2]
  $$

- 当前位置元素为奇数时，操作数Count + 1，并 `Continue`



### 链表中倒数第K个节点

> 输入一个链表，输出该链表中倒数第k个结点。

#### 自己的想法

- 遍历链表，同时开辟一个列表存储所有的值
- 返回倒数第K个值

#### 无需开辟新数组的想法

利用两个指针，一前一后行成一个**“尺子”**, 当尺子的前端（离起点较远的那一端）到达链表的末尾时，此时尺子头所在的位置即为倒数第  K 个数字。如下图所示

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9.png" width = "800"/>
</center>

- 首先初始化两个指针为链表头。
- 将其中一个指针向前移动 K - 1 个位置。这样保证当尺子前端到达链表末尾的时候，尺子后端为倒数第K个数。
  - 这里需要注意判断边界条件，在移动尺子一端的时候，可能会出现两种情况
    - 尺子移动 K - 1 个位置刚好到达链表的末尾。也就是 `尺子前端.next = None`
    - 尺子移动 K - 1 个位置的过程中，超出了链表。此时输入不合法，返回 None
- 尺子定义完成后，只需要同时向前移动尺子的**“前端”**和**"后端"**，当前端达到末尾，返回后端



### 反转链表

> 输入一个链表，反转链表后，输出新链表的表头。

反转链表时需要三个变量。输入链表为单向的，如果直接反转的话，会失去原本的 next 值。

- 创建一个 next 值，在反转当前值之前记录其 next 的位置。
- 创建 last 值，记录当前值的前一个节点的位置。
- 不断移动当前值

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.png" width = "800"/>
</center>

最后需要返回的是 **last** 值。因为在处理最后一个节点时，pHead 成为 None

```python
pLast = None
while pHead:
    pNext = pHead.next
    pHead.next = pLast
    pLast = pHead
    pHead = pNext
return pLast
```



###  合并两个排序的链表

> 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

#### 总结

题目本身不难。需要注意的有以下几点

- **注意判断特殊情况**
  - 一个链表为空的情况。或者两个链表为空的情况
  - 注意思考递归的方式



### 树的子结构

> 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

#### 题目解法

递归搜索。输入两棵树，要判断 B 是不是 A 的子树分为两步：

- 在 A 中寻找到与 B 根节点相同的节点
- 根据搜索到的根节点，递归匹配其左子树与右子树，看是否相等。

<center>
    <img src=  "https://github.com/joseph-mutu/Pics/raw/master/Is%20B%20the%20subtree%20of%20A.png" width = "800"/>
</center>

在判断左子树与右子树是否相同时，有两个终止条件。

```python
def checkEquality(self,pRoot1,pRoot2):
    if pRoot2 is None:
    	return True
    if pRoot1 is None:
    	return False
    if pRoot1.val != pRoot2.val:
    	return False
    return (self.checkEquality(pRoot1.left,pRoot2.left) and self.checkEquality(pRoot1.right,pRoot2.right) ) or  (self.checkEquality(pRoot1.left,pRoot2.right) and self.checkEquality(pRoot1.right,pRoot2.left))
```

- 首先判断 B 树是否到达叶节点再判断 A 树是否到达叶节点。原因如下
  - 假设当前正处于 A 树的节点 9 以及 B 树的节点 9。则两节点相同，继续进行搜索。此时搜索为 `checkEquality(A9.left,B9.left) and checkEquality(A9.right, B9.right)` ,因为以是否到达叶节点为判断依据。如果调换判断的顺序，先判断 `if pRootq is None` 则直接返回 False。
- 停止依据，如果B树到达叶节点，则为True。如果A树到达叶节点则为 False
- 上述两个判断**不可以**改成下述判断

```python
def checkEquality(self,pRoot1,pRoot2):
    if pRoot2 is None and pRoot1 is None:
    	return True
    if pRoot1 is None or pRoot2 is not None:
    	return False
   	if pRoot1 is not None or pRoot2 is None:
        return False
```

原因在于，A 树大于 B 树。考虑当前搜索节点为 A7 和 B7。B树搜索完成，节点全部匹配。现在搜索 `checkEquality(A7.left,B7.left) and checkEquality(A7.right,B7.right)`，则返回 False



### 二叉树的镜像

> 操作给定的二叉树，将其变换为源二叉树的镜像。

#### 题目理解

将二叉树所有的左右儿子进行调换

#### 题目解法

递归求解。

- 当到达二叉树叶节点的时候，返回 None
- 当二叉树为单边数树时，进行`root.right = root.left` 之后，要对 `root.left`赋值为 None

```python
if root.left and root.right:
    tem = root.right
    root.right = root.left
    root.left = tem
    root.left = self.	Mirror(root.left)
    root.right = self.Mirror(root.right)
elif root.left:
    root.right = root.left
    root.left = None
    root.right = self.Mirror(root.right)
elif root.right:
    root.left = root.right
    root.right = None
    root.left = self.Mirror(root.left)
```



### 顺时针打印矩阵

> 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.

#### 题目理解

题目的难点在于如何分析题目。

顺时针打印一共可以分为 4 个步骤：

- 横向打印
- 打印最后一列
- 打印最后一行 （从右二到左） 
- 打印第一行（从底二到上）

打印的操作可以取决于 **4** 个变量：

- 起始行数，起始列数。这两个参数，每次增加1。比如第一次打印时，起始行数起始列数为 （0,0）。第二次打印时，起始行数，起始列数为（1,1）

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B51.png" width = "600"/>
</center>



- 当前的总行数，当前的列的长度。
- 每次结束一圈打印之后，当前的行数以及列数就会 **- 1**。同时起始行数起始列数 **+ 1**

<center>
    <img src= "https://github.com/joseph-mutu/Pics/raw/master/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B52.png" width = "600"/>
</center>

##### 4 种打印所需要的条件

4 中操作有先后顺序。只要前一圈打印结束之后还存有元素没有被打印，第一种操作总会进行

- 第一种操作：只要起始行数，起始列数大于等于**当前行数长度**以及**当前列数长度**
- 第二种操作：在满足第一种操作的情况下，当前**行数至少为 2** 才需要进行第二种操作
- 第三种操作：行数至少为 2 且列数至少为 2。
- 第四种操作：行数至少为 3，列数至少为 2。

当第一种操作的条件不满足时，退出循环。矩阵完成打印

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B54.png" width = "600"/>
</center>



### 包含 min 函数的栈

> 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。

#### 题目理解

要用时间复杂度为 O(1) 得到当前的最小元素。

- 利用另一个堆栈，存储最小元素，第二小元素，第三小...
- 每压入一个元素，进行一次对比，如果比当前的最小值小，则将当前元素压入**原始栈**的同时，压入**最小元素栈**
  - 比如依次压入 “3,4,2,5”。则最小元素栈中存储 ”3,2“ 
- 进行元素 pop 的时候，进行对比。如果当前 pop 元素等于最小元素栈中栈顶元素，则同时将最小元素从最小元素栈删除



### 栈的压入弹出序列

> 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

#### 题目理解

- 建立一个辅助栈，根据题目提供的压入顺序对相应元素进行堆栈。
- 堆栈的同时，对弹出序列进行检测。如果当前入栈的元素与出栈序列相同，则 辅助栈.pop()。同时删去弹出序列中的相同元素。
- 当堆栈结束，但是弹出序列中仍有元素时，表示弹出序列不可能。



###  从上到下打印二叉树

> 从上往下打印出二叉树的每个节点，同层节点从左至右打印。

#### 题目理解

二叉树的遍历。同层节点从左到右打印，依赖队列，先将 root 节点压入队列，然后判断其是否有左右儿子，如果有继续压入队列，然后弹出 root 节点。依次循环，直至队列为空



### 二叉树的后序遍历列表

> 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。

#### 题目理解

首先二叉搜索树意思是：

- 根节点的左子树一定比根节点的值小
- 根节点的右子树一定比根节点的值大

后序遍历的特点在于：

- 遍历结果的最后一个元素一定为当前二叉搜索树的根节点。
- 后序遍历从根节点的左子树开始


$$
\lbrace 1,2,5,8,6,3 \rbrace
$$
则 3 一定为当前搜索树的根节点。

- 根据后序遍历的特点，当前搜索树的左子树为后序遍历序列中，从 0 位置开始比根节点小的值。右子树为剩余的值。以上述二叉树举例

$$
左子树: \lbrace 1,2  \rbrace \\
\space \\
右子树: \lbrace 5,8,6 \rbrace \\
$$

且左子树一定是从 0 位置开始，连续的比根节点大的值。右子树同样一定是连续的位置的值

#### 题目解法

- 提取二叉搜索树的根节点
- 按照根节点，提取其左子树的值（从 位置 [0] 开始比较，一直比较到大于根节点的位置为止）
- 此时剩余的值为右子树的值
- 扫描右子树的值，如果**出现比根节点小的值**则该序列不可能



### 二叉树中和为某一路径的值

> 输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)

#### 题目理解

重点在于递归向下，返回的时候要回退到当时的状态。

- 比如递归到左子树的叶节点 1 时，发现路径符合，则将当前路径添加进最终的路径，并返回上一层节点
  - 递归调用的时候，传入的路径是一片相同的地址，所以，在不断递归向下的时候，当前的路径也在不断添加新的节点。在回传的时候，要注意删除当前的节点。

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/path%20Sum%20in%20binary%20search%20tree.png" width = "750"/>
</center>



### 复杂链表的赋值

> 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）

#### 题目理解

相较于传统列表，复杂链表多了一个指向任意节点的指针

#### 题目解法

##### 使用字典

- 按照原链表的顺序以及相应的值，每次新建一个节点并赋相同的值，进行连接
  - 同时，将原链表相对应的节点，和新建的节点，进行一一配对，存储进一个字典
- 从头扫描新链表以及原链表，如果原链表中相应节点存在 pHead.random 的话，将其读入字典，找到在新链表中对应的节点，进行连接

```python
if pHead.random:
	newHeade.random = self.totalDic[pHead.random]
```

##### 不使用字典

- 按照原链表的顺序，在原链表上对其进行复制，如下

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A81.jpg" width = "500"/>
</center>

- 从新扫描该链表，如果原链表的节点存在 random，则进行连接

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A82.jpg" width = "500"/>
</center>

```python
# pHead 只指向原链表的节点。A，B，C，D，E
newHead = pHead
if pHead.random:
	newHead.random = pHead.random.next
```



- 将两个链表分离

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A83.jpg" width = "500"/>
</center>

### 二叉搜索树与双向链表

> 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

#### 题目理解

首先明确，二叉搜索树的左子树的所有节点**小于**根节点，右子树的所有节点**大于**根节点。最终返回头结点

- 当只存在一棵树（一个根节点，以及一个左叶节点，一个右叶节点）
  - 排列顺序为 左叶 --> 根节点 --> 右叶节点
- 递归求解的过程中，
  - 对于左子树，要将**左子树中的最大值**与根节点相连接
    - 由于题目返回头结点，在递归求解过程中，头结点为当前序列的最小值。连接左子树时，每次要寻找到排好序的序列的最右节点并返回。
  - 对于右子树，要将**右子树中的最小值**与根节点相连接
    - 头结点为当前序列的最小值，所以右子树只需要返回头结点即可

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%92%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" width = "900"/>
</center>



### 字符串中的所有排列

> 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。
>
> ```
> 输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。
> ```

#### 题目理解

以字符串 “abc”举例，
$$
"a": 0 \space \\
"b":1 \space \\
"c":2
$$
是一个递归的过程，首先字符串的 start 和 end 均在首位。这里需要注意一点。以下代码是不进入 print 函数的，会直接返回

```python
for i in range(0,0):
	print(i)
```

- 首先初始状态为 abc, 将字符串 0 与 0 的位置进行交换。
  -  递归进入下一个状态 bc, 将此时字符串的 1 与 1 的位置进行交换
    - 同时递归再进入下一个状态 c，此时到达字符串的末端，将当前字符串添加进可能的序列 **"abc"**，返回上一状态
  - 因为从下一状态返回当前状态时，要将已经交换的字符串恢复原位，所以再将 1 与 2 的位置进行交换
  - 将字符串 0 与 1 的位置进行交换，此时字符串为 cb, 递归进入下一状态
    - 此时状态为 b，到达末端，添加 **“acb”** ，返回上一状态
  - 将已经交换的字符串恢复，交换 cb，当前字符串为 **abc** 。因为上一步将 1 与 2 的位置交换。则到达当前状态末端，返回上一字符串
- 将字符串归为，将  0 与 0 再次交换
- 进行 0 与 1 的交换，当前字符串为 bac
  - 递归进入下一状态 ac

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97.png" width = "800"/>
</center>



#### 题目难点

遇到字符串中存在重复的字符时，以 “abb”举例

- 对于位置 0 **（a）** ，该位置递归有 3 个可能
  - 位置 0 与 位置 0 
  - 位置 0 与 位置 1
  - 位置 0 与 位置 2
- 发现，位置 0 与 位置1交换后 为 "bab"
  - 位置 0 与 位置 2 交换后仍为 “bab”
  - 且随后的递归状态相同
    - a 与 a 交换
    - a 与 b 交换 ，到达尾部，添加 **“bab”**

则，**如果当前其实位置，与当前递归位置之间，存在重复的元素，则跳过，递归位置 + 1**



### 数组中出现超过一半的数字

> 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。

#### 题目解法

数组中某一数字出现超过一半，意即**该数字出现的次数，超过其他所有数字出现次数之和**，

- 从数组头开始扫描，遇到第一个数字，将其记住，并将其出现的次数记为1
- 遇到第二个数字，若与第一个数字不同，则次数 -1 。
- 当出现次数为 0 时，初始化。重新记住下一个出现的数字，并将其出现的次数记为1 
- 将得到的数字，进行检查，是否出现次数超过一半
  - 如果为否，则说明数组中没有这种数字



### 最小的 K 个数

> 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。

Partition 函数参考: [浙江大学MOOC 数据结构](http://www.icourse163.org/learn/ZJU-93001?tid=1003997005#/learn/content?type=detail&id=1007588514&cid=1009165154)

---

#### 题目解法

题目用到了在快速排序中使用的 Partition 函数

- 每次选定一个数作为 **Pivot**，将数组分为左右部分
- 左边部分全为小于等于 **Pivot** 的值，右边部分全为大于 **Pivot** 的值
- 如果当当前的 **Pivot** 的数组位置为 **K- 1** 时，则数组左边即为所求的最小的 **k** 个数



<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/Partition%20%E5%87%BD%E6%95%B0.png" width = "1200"/>
</center>

Note:

- 指针移动时，先移动左指针再移动右指针
  - 当左指针遍历完成后，它指向大于 Pivot 部分的值，然后停住
  - 此时右指针开始移动，并指向左指针的最后一个元素（小于 Pivot 部分的值），停住
    - 注意要进行判断交换，因为**左右指针均停住**是**之前进行元素交换**的条件
    - 但是此时左右指针的元素不进行交换
  - 此时，左指针的位置，既是与 Pivot 元素交换的值

```python
while data[leftPointer] < data[Pivot]:
	leftPointer += 1
while data[rightPointer] > data[Pivot]:
    rightPointer += 1
if leftPointer < rightPointer:
    Swap(leftPointer,rightPointer)
```



### 连续子数组的最大和

> HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)

#### 题目解法

求得连续子数组的最大和。

- 从数组头开始扫描，遇到一个数加一个数（无论正负），将值付给 temSum，并随时更新 maxSum 的值，当temSum > maxSum 时更新
- 当temSum 为负时表示**之前的序列**不会给**之后的序列**带来**值上的增益**，将 temSum 重置为 0，重新进行记录



### 整数中 1 出现的次数

> 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。

#### 自己的想法

将每一个数化为 `string`， 然后对 string 中每一个位置进行对比，如果是 1 的话，就将 count_1 + 1。时间复杂度为 $O(nlogn)$

#### 题目解法

参考：[[从1到n整数中1出现的次数](https://www.cnblogs.com/xuanxufeng/p/6854105.html)]

---

以数字 `31526` 举例。每次统计每一个 `位` 上 1 在当前数字下，出现多少次。意即，个位上到 31526 一共能出现多少次 1，十位上 到 31526 一共能出现多少次 1 

- 首先按照位数将数字拆分。如果当前查找状态为 十位数，则将 31526，拆分成 $3152|6$ 两个部分。
- 将 3152 + 8。根据如下讨论，十位数出现 1 的次数将取决于原数字的十位数（也就是3152 末尾的2）是否大于 1，还是等于1 还是等于 0。大于1 与 等于 0 两种情况可以合并计算
  - 若原数字十位数 等于 0，假设为 3150，则加上 8 ，在进行 /10 操作，仍为 315。则表示在十位上出现 1 的次数为 315 + 1
  - 若原数字十位数大于 1，加上 8 则刚好进位。说明在十位上出现 1 的次数为 316 + 1
- 若十位的数字为 1 
  - 则十位上出现1的次数 要再加上 10,11,12,13，14,15,16 ，7 次

#### “位数”解释

##### 个位

###### **当原数中的个位大于 1 时**

`31526` **中个位为 6**
$$
0|1 \rightarrow 1|1 \rightarrow 21 \rightarrow 3|1 \ldots 3151|1 \rightarrow 3152|1
$$
每隔 10 个数出现 1 次

则 31526 中一共出现 3152 次个位数中的 1，再加上 个位上的 6 因为 大于 1 则 一共有 3152 + 1 次

###### 当原数中的个位等于 1 时

假设当前的原数为 `31521` 


$$
0|1 \rightarrow 1|1 \rightarrow 21 \rightarrow 3|1 \ldots 3151|1 \rightarrow 3152|1
$$


###### 当原数中的个位等于 0 时

假设当前的原数为 `31520` 


$$
0|1 \rightarrow 1|1 \rightarrow 21 \rightarrow 3|1 \ldots 3151|1
$$

##### 十位

###### 当原数中的十位大于 1 时

原数为 `31526` ，其十位数为 2。在 十位数的区间，1 会出现在


$$
10 \rightarrow 19
$$
且每隔 100 个数出现一次



Note: 现在讨论的是 `位`上出现1 的可能。21，31 之类的为个位的情况，已经被个位包含在内

---

则
$$
0|10 \rightarrow 0|19 \\
\space \\
2|10 \rightarrow 2|19 \\
\space \\
3|10 \rightarrow 3|19 \\
\space \\
\ldots \space \\
\space \\
315|10 \rightarrow 315|19
$$
一共出现了 315 + 1 次 1



###### 当原数中的十位等于 1 时

假设原数为 `31513`, 其十位数为 1

则
$$
0|10 \rightarrow 0|19 \\
\space \\
2|10 \rightarrow 2|19 \\
\space \\
3|10 \rightarrow 3|19 \\
\space \\
\ldots \space \\
\space \\
314|10 \rightarrow 314|19 \\
\space \\
315|10 \rightarrow 315|13
$$
则 1 一共出现了 （314 + 1）+ 3 + 1 次

###### 当原数中的十位等于 0 时

假设原数为 `31503` ,其 十位数 为 0

则 一共出现了 315 次
$$
0|10 \rightarrow 0|19 \\
\space \\
2|10 \rightarrow 2|19 \\
\space \\
3|10 \rightarrow 3|19 \\
\space \\
\ldots \space \\
\space \\
314|10 \rightarrow 314|19 \\
$$



### 把数组排成最小的数

> 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。

#### 题目解法

将数字转化为字符串

- 重新定义比较规则
  - 假设当前有两个数，3 和 12
  - 首先将两个数合并，有两种可能， 312 和 123
  - 因为 312 大于 123
  - 则 12 比 3 小，12 排在 3 的前面
- 按照新的规则定义之后，将数组排序，按照排好序之后的顺序，将所有数组拼接，得到的新的数即为最小的数



### 丑数

> 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

#### 题目理解

只包含质因子2,3,5，意即只能被 2,3,5 分解至1 的数，判断如下

```python
while number%2 == 0:
	number /= 2
while number%3 == 0:
	number /= 3
while number%5 == 0:
	number /= 5
if number != 1:
	# 该数字不只包含质因子 2,3,5
```

#### 题目重点

- 不需要对每个自然整数都进行判断，为了得到下一个丑数，一定是其之前的丑数乘上 2,3,5 得到的数
- 每个已经确定的丑数都存在 3 种可能，乘上  2,3,5，得到下一个丑数，下一个丑数要取在可能的丑数中最小的
  - 如下图所示，当选取某一个数的某一个可能时（下一个丑数是该数 x2/x3/x5）,则将对应的指针向前移动，代表这个数的这个可能被选择了
  - 当遇到有相同的数时，如，丑数 2 的 x3 可能，以及 丑数 3 的 X2 可能，则同时向前移动

<center>
    <img src= "https://github.com/joseph-mutu/Pics/raw/master/uglynumbers.png" width = "800"/>
</center>

### 第一个只出现一次的数

> 在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.

#### 题目理解

利用字典，统计每一个字符在字符串中出现的次数，统计结束后，返回字典的所有 `值`，选择第一个为 1的返回，若没有，则返回 -1



### 数组中的逆序对

> 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007
>
> 示例:
>
> 输入：1,2,3,4,5,6,7,0
>
> 输出：7

#### 题目理解

利用归并排序，在每次进行两个子序列的归并的时候，统计逆序对。以
$$
[2,3,9,12,7,4,5,8,10]
$$
举例进行说明。

**第一次归并**： **length = 1**

统计时，只考虑相邻的子序列，2和3,9 和 12，7 和 4,5 和 8，以及 10

当 length 为 1 时，在 第三对子序列 {7,4} 进行排列时发现

- 左边的元素大于 右边的元素，
- 逆序对  + = 1
  - 因为左序列在原数组中也是在左侧的位置，所以左侧元素大于右侧元素，被视为逆序对
  - 逆序对统计完之后，将两个数交换，相当于消去这一逆序对

$$
\underbrace{2,3},\underbrace{9,12},\underbrace{4,7},\underbrace{5,8},\underbrace{10}
$$



**第二次归并：length = 2**

以第二对相邻子序列 $[4,7] and [5,8]$ 进行说明

- 首先扫描 4 以及 5（两个子序列的起始位置），4 < 5, 无逆序对. 将 4 放进临时数组中
- 左指针指向 7，右指针仍旧指向 5。此时 7 > 5, 左元素大于右元素，逆序对 + 1，消去当前逆序对。将 5 填入临时数组



Note: 注意归并排序本身的性质，

- **每次进行比较的两个子序列一定是有序的**，归并排序从单个的元素开始，逐渐增加 length
- 归并排序的左子序列，在原数组的位置上，相对于右子序列也是靠左的

下面以两个有序子序列说明逆序对的统计：
$$
 [\underbrace{9},12,14,15] ~~ [\underbrace{4},8,20,22]
$$

- 左指针为 9，右指针为 4
- 因为 9 > 4, 则构成逆序对。但是此时并不是将逆序对 +1,而是加上当前左子序列的长度 - 左指针位置
  - 因为，如果 9 > 4，而且左子序列有序，则 9 后面的元素均与 4 构成逆序对
  - 在归并排序中，下一步的操作是将 4 当放入临时数组，相当于忽略 4，则需要统计所有与 4 相关的逆序对

### 

### 两个链表的第一个公共节点

> 输入两个链表，找出它们的第一个公共结点。

#### 题目理解

所谓公共节点，是两个链表指向了同一个节点。因为为单向链表，如果两个链表指向同一节点，则两链表共享之后的所有节点。

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9.png" width = "800"/>
</center>



#### 题目解法

##### 自己的想法

- 遍历第一个链表，按照 `链表值` -- `链表节点地址` 的方式，存储第一个链表的每一个节点
- 遍历第二个链表，如果扫描中发现存在相同值的节点，则返回



##### 剑指offer 想法

- 遍历两个链表，并分别记录下两个链表的长度
- 将较长的链表先移动其头结点，当较长链表与较短链表长度一致时停止
- 两联链表同步扫描，如果碰到相同的节点，则返回。



### 数字在排序数组中出现的次数

> 统计一个数字在排序数组中出现的次数。

#### 自己的想法

- 利用二分，先找到数组中等于 k 的数
- 然后向左右两边扩展，左边数到第一个不是 k 的数停下，右边数到第一个不是k的数停下
- 统计一共有多少个相同的 k

##### 问题

因为要向左右两边扫描，所以当整个数组均是同一个数的时候，时间复杂度依然为 O(n)



#### 论坛中的想法

因为数组中的全为整数，利用二分法搜索 k-0.5 以及 k + 0.5 应该存在的位置，然后两个位置相减就是答案

##### 对二分法的越界进行分析

###### 当数组中存在多个 k 值

以下列数组举例说明, 

**首先搜索  2.5**
$$
[1,2,3,3,3,3,4,5,6,7,8]
$$

- start = 0, end = len(data) - 1 = 10, mid = 5, data[5] = 3 > 2.5
- start = 0, end = 4, mid = 2, data[2] = 3 > 2.5
- start = 0, end = 1, mid = 0, data[0] = 1 < 2.5
- start = 1, end = 1, mid = 1, data[1] = 2 < 2.5
- start = 2, start > end 返回 start 位置 2， 数组中第一个 3 的位置

**搜索3.5**

- start = 0, end  = 10, mid = 5, data[5] = 3 < 3.5
- start = 6, end = 10, mid = 8, data[8] = 6 > 3.5
- start = 6, end = 7, mid = 6, data[6] = 4 > 3.5
- start = 6,end = 6, mid = 6, data[6] = 4 > 3.5
- start = 6, end = 5 , 结束，返回 start 位置 6，数组中第一个大于 3 的位置

###### 当数组中全为 3

以下列数组举例
$$
[3,3,3,3,3]
$$
**搜索 2.5**

- start  = 0, end = 4,mid = 2 ,data[2] = 3 > 2.5
- start = 0, end = 1, mid = 0, data[0] = 3 >2.5
- start = 0, end = 0, mid = 0 ,data[0] = 3 > 2.5
- start = 0 ,end = -1, 结束 返回 start , 位置 0，第一个 3 的位置

**搜索 3.5**

- start = 0,end = 4, mid = 2, data[2] = 3 > 2,5
- start = 3, end = 4, mid = 3,data [3] = 3 > 2.5
- start = 4, end = 4, mid = 4, data[4] = 3 > 2.5
- start = 5, end = 4，结束，返回 start ，第一个大于 3 的位置**(越界)**



Note：

- 搜索 小于 3 而数组中不存在的值，总会返回 第一个 3 的位置
- 搜索大于 3 而数组中不存在的值，会返回第一个大于 3 的位置



### 二叉树的深度

> 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。

#### 题目解法

进行递归，求解树的深度

需要注意的是，可以从尾部进行递归，每次 + 1

```python
def get_height(self,pRoot):
	if pRoot is not None:
		return max(self.get_height(pRoot.left),self.get_height(pRoot.right)) +1
	else:
		return 0
```

上述代码，

- 在到达根节点时，比如说 1，继续进行 `self.get_height(pRoot.left)` `self.get_height(pRoot.right)` 得到两个 0 值，然后 本身深度 + 1，则 1 节点为深度 1 
- 将 1 的深度赋值给 3.left = 1, 同样 3.right = 1, 向上传递时当前深度 + 1

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.png" width = "800"/>
</center>



### 平衡二叉树

> 输入一棵二叉树，判断该二叉树是否是平衡二叉树。

<center>
    <img src= "https://github.com/joseph-mutu/Pics/raw/master/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%A4%E5%AE%9A.jpg" width = "800"/>
</center>

#### 自己的想法

- 将所有节点依次遍历，每个节点都求当前节点的左右子树的高度差
- 如果高度差 > 1，则 `return False`

##### 问题

会对子树进行多次遍历

#### 论坛想法

从底层遍历，如果当前某一个节点的左右子树的高度差超过 1，则直接返回 False。以上图中间的二叉树举例

- 将根节点 6 传入，要求 6 的左右子树的高度差，需要对 4 和 8 进行遍历
- 求 4 的深度，需要进行 1 和 5
- 求 8 的深度，需要求 9 
- 在某一层发现某一个节点不满足平衡二叉树的条件时，直接一路返回





### 数组中只出现一次的数字

> 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

#### 自己的想法

- 利用字典，从第一个数字开始，`键` 为数字的值，`值`为数字出现的次数

- 当数字再次出现的时候，将该`键`  `值` 删除

  - 如何判断数字再次出现

  - ```python 
    if dic[num] in dic:
    	del dic[num]
    ```



### 异或方法

<u>一组数字均成对出现，只有一个数单独出现，此时对这个数组从 data[0] 的位置开始进行异或，最后剩下的就是这个单独出现的数字</u>

#### 异或

**参与运算的两个值，如果其相应二进制位相同，异或结果为 0，相应二进制为不同，异或结果为 1**

如 3 的二进制为 11，2 的二进制为 10，4 的二进制位为 100

下面以下列数组进行异或方法的说明
$$
[3,4,3,2,4]
$$

- 从第一位开始进行异或，则最终的结果为数组中仅出现一次的 2
- 

$$
3:011~~~~~~~~~~~~~~7:111~~~~~~~~4:100~~~~~~~~6:110\\
4:100~~~\Rightarrow~~~~~3:011~~~~~~~~2:010~~~~~~~~4:100\\
-------------------\\
7:111~~~~~~~~~~~~~~4:100~~~~~~~~6:110~~~~~~~~2:010
$$



### 和为 S 的连续正数序列

> 输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序

#### 题目方法

以目标为 15 举例

- 定义一个 start = 1，end = 2，当前序列 start ~ end 之和为 3
- 如果当前和 > 目标值，说明当前的序列和大，所以要进行缩小
  - 缩小时从 start 开始缩小，因为 start 是最小的值，也就是 start 向前移动，并更新 curSum
- 如果当前和 < 目标值，说明当前的序列和需要进行扩大，则 end 向下移动一位，并更新 curSum
- 如果当前和 == 目标值，则对当前序列进行添加
  - 注意，**序列和添加时需要判断**，`end - start > 1`，否则 15 这个单个数也会被添加进序列
- 往复循环，**大于** int(target/2) + 1
  - int(target/2) + 1 这个数是最后一个可能的数字，因为题目要求必须要连续的两个数字，则从 1 ~ 15 中间的那个数字就是最后一个可能的连续数字。中间数之后的数均大于中间数，且两者之和肯定大于 15
  - int(15/2) + 1= 8

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%95%B0%E5%AD%97.png" width = "800"/>
</center>



### 排序数组中和为 S 的数字

> 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。

#### 题目理解

- 定义一个 start 一个 end，start 为数组为 0 的位置，end 为数组最后一个数字
  - 数组最后一个数字最大，要搜索所有可能，自然要从数组最小的数字开始
- 如果当前两个数字的和大于 target ，则需要减小当前数值，将 end 向前移动一位
- 如果当前两个数字的和小于 target，则需要增加当前的数值，则将 start 向后移动一位
- 如果当前两个数字的和等于 target，则判断当前两个数字的乘积是否大于当前的最大乘积
  - 如果小于，则更新输出的两个数，并将 start + 1
  - 如果等于，则直接 start + 1



### 左旋转字符串

> 对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”

#### 自己的解法

- 将字符串列表化
- 每次将第一个字符先添加到列表尾部
- 删除第一个字符

#### 剑指offer解法

- 设定一个翻转函数
  - 实现的功能为：给定 start 和  end，翻转 start 和 end 之间所有的字符
  - 实现方法：start 在字符串头部，end 在字符串尾部，每次交换 start 和 end
    - start += 1， end -= 1
    - 终止条件为 start >= end
- 要完成上述前 k 个字符串左旋，需要进行三次翻转
  - 前 k 个字符定义为 X，字符串剩下字符定义为 Y
  - 则 YX = $(X^TY^T)^T$ , 意即先将前 k 个字符串翻转，再将后 Y 个字符串翻转，最后整体翻转



### 翻转单词顺序列

> 例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。

#### 题目解法

利用上一题的 Reverse 函数

- 先将单词整体翻转
- 将单词按照空格分隔
- 将每个单词再次进行翻转

#### 出现的问题

问题出在 Python 的 `string.split(" ") `函数

如果输入一个空格字符串 “ ”，则 `string.split(" ")` 会返回一个列表，里面两个空元素 ['','']

##### 解决方法

利用 Python 的 set函数，先对字符串进行判断，如果字符串 `len(list(set(string))) == 1` 并且 `list(set(string))[0] == " "` 则表示输入字符串全为空格，则直接进行返回

### 扑克牌顺子

> LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)...他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子.....LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。



#### 题目理解

看 5 张牌是否连续，且大小王视为特殊数字，可以填补任何空缺

- 填补空缺，意即相邻两张牌的差值大于1时，大小王可以填补 1
  - 比如，3 和 5，中间差值为 2，大小王可以填补一个差值变为 345
  - 但是这项统计必须在数组排序的情况下进行

则需要进行以下工作：

- 将数组排序
- 扫描数组
  - 统计 0 的个数
  - 统计**非 0 元素**之间的差值
- 如果 0 元素的个数大于非 0 元素的差值，则可以成为顺子
- 如果数组出现多个相同数字，则返回 False



### 孩子们的游戏（约瑟夫圆环问题）

> 给定 人数 n（编号从 0 ~n-1），以及数字 m。从 0 开始报数，数到 m - 1的人被淘汰。此时从 被淘汰的人的下一个人开始从新编号，继续报数，淘汰，直到只剩下一个人为止，求这个人的编号为多少

#### 题目理解

如下图所示，每次淘汰一个人之后，从下一个人开始从新计数，成为一个新的圆环问题

注意一点，每次淘汰一个人之后，成为新的圆环，它们的`解` 不变，并且可以预见的是，最小的圆环为一个人，解在最小的圆环中编号为 0，如果能够找到与之相对应的上一个圆环的对应位置的编号，不断向前追溯，就可以找到在第一个圆环中其相应的编号，也就是答案

注意，推导过程为：每次从**当前圆环**推导**上一圆环**的对应位置编号

以下图为例说明，从第二个圆环（第二列）推导第一个环的对应编号

- 0 + 3 = 3 % 6 = 3
- 1 +3 = 4 % 6 = 4
- 2 + 3 = 5 % 6 = 5
- 3 + 3 = 6 % 6 =0
- 4 + 3 = 7 % 6 = 1



<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/joseph%20circle.png" width = "800"/>
</center>

当 m > n 的情况让我困惑了一阵，但是从规律来看，和 m < n 情况相同

- 0 + 9 = 9 % 6 = 3
- 1 + 9 = 10 % 6 = 4
- 2 + 9 = 11 % 6 =5
- 3 + 9 = 12 % 6 =0
- 4 + 9 = 13 % 6 = 1

则从可以肯定的最后一个圆环的 0 一直向上追溯，可以追溯会其最初的位置



### 求1+2+3+...+n

> 求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

#### 题目想法

利用逻辑短路的方法。

##### 逻辑短路

在 Python 中的判断 `and` 和 ` or`

在 and 判断中

```python
return a and b
```

如果 a 为假，则直接会返回 a 比如

```python
return 0 and 1
```

会返回 0

在 or 判断中

```python
return a or b
```

如果 a 为真，则直接会返回 a

比如

```python
return 1 or 0
```

则会返回 1

```python
return 0 or 1
```

则也会返回 1





### 不用加减乘除做加法

> 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。

#### 题目理解

利用位运算模拟加法运算，计算如下

- 将数字使用二进制表示（正数以及负数都使用补码进行表示，正数的补码就是其本身的二进制码），将第一个数字记为` num1 `, 第二个数字记为` num2  `

- 计算 ` num1 ` 和 ` num2 ` 二进制码互加，但不进位

  - $$
    00101\\
    10001 \\
    -----\\
    10100
    $$

  - 这一操作可以利用 `num1`  ^ `num2` 进行模拟

- `num1` 和 `num2` 的进位表示

  - $$
    00101\\
    10001\\
    -----\\
    00010
    $$

  - 上式只有倒数第二位进位，其他位置皆为 0

  - 这一操作，可以用 （num1 & num2） << 1进行模拟

    - 先对两个数进行位与操作，再左移

- 将第一步不进位的结果赋予 `num1`

- 重复第一步，num1 = `num1` ^ `num2`相加不进位

- 直到进位表示为 0 结束



#### Python 中存在的问题

Python 计算负数进位的时候不会溢出。其他语言在计算负数进位的时候，到达 $2^{32}$ 时，会溢出成为 0，但是 python 数值可以无限大

```python
class Solution:
	def Add(self, num1, num2):
		while num2 != 0: 
			sum_without_carry = (num1^num2) & 0xffffffff
			num2 = (num1 & num2) << 1 
			num1 = sum_without_carry 
		return num1 if num1 >> 31 == 0 else num1 - 4294967296
```

上述程序在 return 时候判断 `if  num1 >>31 == 0` 为检测当前值是否为正数，如果为正数直接返回。（正数右移 31 位一定为 0，32 位系统下范围为 [$2^{32}, 2^{31}-1$]）





### 把字符串转换成整数

> 将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。
>
> ## 输入描述:
>
> ```
> 输入一个字符串,包括数字字母符号,可以为空
> ```
>
> ## 输出描述:
>
> ```
> 如果是合法的数值表达则返回该数字，否则返回0
> ```



#### 题目理解

- 将字符数字转为 int 类型，如果有非字符数字型的字符出现，则直接返回 0
- 在输入字符串的开头，会有 `+` 和 `-` 表示输入的正负号，如果没有正负号表示则默认按照 `+` 处理

#### 题目解法

- 建立一个合法的数组，数组中存有 `['1','2','3','4','5','6','7','8','9','+','-']`

- 首先判断字符串首，如果存在正负号表示，则将 `Pos_Neg` 符号按照相应的正负号设置成  +1 或者 -1

  - 如果字符串首没有正负号，则返回默认的 `Pos_Neg` 符号为 +1 

- 扫描剩余字符串，如果存在非法字符 如 `‘l’` 或者 `'a'` 等字符，直接返回 0

  - 如果为 合法字符则

  - ```python
    sum = sum*10 + legal_dic.index(str)
    ```

  - 每次将 sum *10 代表将新的数字添加到新位置上。sum 初始为 0，若输入字符串的第一位为 2，则 sum = 0 * 10 + 2 = 2





### 数组中重复的数字

> 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。

#### 自己的想法

- 建立一个字典，其中 `键` 为数字，`值` 为数字出现的次数
- 从头到尾扫描数组，如果当前数字存在于字典当中，则直接返回
- 如果扫描完成后，返回 False



#### 剑指offer 的解法

因为数组的数字全部在  0 ~ n-1 的范围之内，所以利用这一范围，当前数字就存在于数字值的这个位置。比如，0 就在 0 这个位置，2 在数组中就在 2 这个位置

- 开始扫描数组，如果当前数字与当前位置相匹配，则向前进

- 否则，进行交换。将当前数字与其位置上所在的数字进行交换

  - $$
    [2,3,1,4,0]
    $$

  - 以上述举例，第一位为 2， 2 应该在数组中的 `2` 位置，则进行交换。交换之后为

  - $$
    [1,2,3,4,0]
    $$

  - 继续查看当前数字是否与当前位置匹配，如果不匹配，继续与其匹配位置交换

- 如果在交换的过程中发现，要交换的位置与当前交换的数字一致，则说明数字中有重复的值

以下列举例子
$$
[2,3,1,0,2,5,3]
$$

- 当前位置为0，当前位置元素为 2，不匹配，进行交换

  - $$
    [1,3,2,0,2,5,3]
    $$

- 当前位置仍旧为  0，当前位置元素为 2，不匹配，进行交换

  - $$
    [3,1,2,0,2,5,3]
    $$

- 当前位置为 3，当前位置元素为 3，不匹配，交换

  - $$
    [0,1,2,3,2,5,3]
    $$

- 当前位置为 0，当前元素为 0，匹配，前进

- 当前位置为 1，当前元素为 1，匹配，前进

- 当前位置为 2，当前元素为 2，匹配，前进

- 当前位置为 3，当前元素为 3，匹配，前进

- 当前位置为 4，当前元素为 2，不匹配，交换

  - 交换位置元素与待交换元素一致，元素重复，返回





### 构建乘积数组

> 给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。

#### 自己的想法

并没有好的想法，只想到利用直观解法



#### 剑指 offer 解法

- 将 B 矩阵视为由左右两个数组的乘积
- 一个矩阵从顶向下进行构建，一个矩阵从底向上进行构建
- 最后两个数组相乘得到 B 矩阵

<center>
    <img src ="https://github.com/joseph-mutu/Pics/raw/master/%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84.jpg" width = "500"/>
</center>



### 正则表达式匹配

> 请实现一个函数用来匹配包括 '.' 和 '*' 的正则表达式。模式中的字符 ' . ' 表示任意一个字符，而 * 表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但是与"aa.a"和"ab*a"均不匹配

#### 题目解法

分情况进行递归

- 如果当前字符串 s[0] 和模式字符串中 pattern[0] 相等
  - 则当前字符串匹配成功，进行下一字符的匹配，`self.match(s[1:],pattern[1:])`
- 如果当前字符串 s[0] 与模式字符串中的 pattern[0] 不相等，但 pattern[0] = "."
  - 因为 “.” 可以表示任意字符串，则继续进行下一字符的匹配，`self.match(s[1:],pattern[1:])`
- 如果模式字符串中的 pattern[1] 的位置 pattern[1] == "*" ，则说明出现星号匹配模式
  - 如果当前 s[0] != pattern[0]，因为星号，则直接跳过 pattern 当前的字符，进行下一字符的匹配 `self.match(s,pattern[2:])`
  - 如果当前 s[0] == pattern[0]，则分情况
    - 进行匹配 `self.match(s[1:],pattern)`
    - 不进行匹配 `self.match(s,pattern[2:])`

##### 停止条件

- 当 s 字符串为空，且模式字符串也为空时，为 `True`
- 当 s 字符串不为空，但模式字符串为空时，为 `False`
- 当 s 字符串为空，但是模式字符串不为空时
  - 如果模式字符串的最后两个值为 `x*` 则为 `True`
  - 否则则为 `False`

#### 字符串是否为空的判定

假设当前字符串为 `a = 'a'` ，则 

```python
a[1:]
```

得到的不是一个 None，而是一个空字符串，即 len (a[1:]) == 0



### 表示数值的字符串

> 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是

#### 题目分析

问题在于清晰地想明白过程

对于当前字符的判断分为以下四种情况：

- 当前字符为 `e/E`
  - 只能出现一次
  - 后面只能出现 `+/-` 和 `0~9`
    - 当出现 `+/-` 时判定其之前的一个数是否为 `e/E`
  - 不能出现在最后一位
  - 不能出现 `.`
- 当前字符为 `+/-`
  - 如果出现在字符串起始位置，则其之后一定为 `0~9`
  - 如果没有出现在字符串的起始位置，则其之前一定为 `e/E`
- 当前字符为非上述字符之外的 `非法字符`
  - 出现非法字符，直接返回 False
- 当前字符为 `.`
  - 只能出现一次
- 当前字符为 `0~9`
  - 继续

在写程序的时候，按照每一种情况分别进行判定





### 字符流中第一个不重复的字符

> 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是"g"。当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"。  

#### 题目解法

##### Insert

利用一个字典存储字符流的出现次数，利用一个数组存储出现的单词字符

- 如果当前字符存在于字典中
  - 说明当前字符出现次数 > 1
  - 如果当前字符存在于数组中，则进行 pop
    - 如果不存在于数组中，则继续
      - 如果不存在与数组中，则是之前就已经 pop 出数组，所以不会影响
- 如果当前字符不在字典中，说明是第一次出现
  - 数组.append(char)

##### Return

返回数组的第一个值，如果数组为空，这说明没有出现一次的字符，返回 `#`



### 链表中环的入口节点

Note: 进行链表的操作时刻要注意 None 出现。要注意指针的有效性

> 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。

#### 自己的解法

利用字典存储每一个节点的地址，不断移动头结点，如果碰到一样的地址，则该地址所在的节点即为环的入口节点

#### 剑指 offer 的解法

将整个寻找环的入口节点分为三个部分

- 判定当前链表是否存在环
- 判定环的长度
- 寻找入口节点

##### 是否存在环

定义两个指针，一个指针每次移动一步，另一个指针每次移动两步，如果存在环则必定两个指针会相遇

- 如果快的指针先遇到 None，则说明当前链表不存在环

##### 判定环的长度

在存在环的情况下，从两个指针相遇的地方开始，一个指针不动，另一个指针每次移动 1 的距离，`self.chain_length += 1`当两个指针再次相遇时，则 `self.chain_length` 即为环的长度

##### 寻找入口节点

从头开始，定义两个结点。一个节点指向 `head` 另一个节点向前移动 `self.chain_length`步，然后两个指针同步进行移动，每次移动 1 的距离，当两个结点指向的地址相同时，则当前地址即为环的入口节点





### 删除链表中重复的节点

> 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5

#### 题目解法

利用两个指针，`det1` 指向不确定的一个节点，`det2` 指向其下一个节点

- 利用 `det2` 以及 `det2.next` 判断是否存在相等的节点
  - 则最终 `det2` 会停在相等节点的最后一个节点
  - 将 `det1` 指向的节点连接到此时的 `det2.next`

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9.png" width = "700"/>
</center>

为了处理链表中开头就是重复的节点的情况

- 添加一个虚拟节点，则此时 `det1` 指向 -999，`det2` 指向第一个 1
- `det2` 停在最后一个1 处, det1 连接到 None
- 检测到 None，返回 `-999.next`

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B92.png" width = "800"/>
</center>



### 二叉树的下一个节点

> 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

#### 题目解法

分析以下述二叉树为例，其中序遍历顺序为
$$
[4,2,13,17,5,7,2,1,3,9,0]
$$
二叉树的下一个节点分为三种情况：

- 当前节点存在右子树
  - 则对右子树进行搜索，一直搜索返回右子树的最左的叶节点
- 当前节点不存在右子树
  - 如果当前节点没有父节点
    - 说明当前节点是根节点，则返回当前节点
  - 如果当前节点存在父节点
    - 如果当前节点的父节点的左子树
      - 返回父节点
    - 如果当前节点是父节点的右子树
      - 如果当前节点的父节点 **不存在** 父节点
        - 返回 None，说明当前节点的父节点为根节点，因为当前节点是右子树，所以根节点已经遍历过了，所以当前节点为中序遍历的最后一个值
      - 如果**当前节点的父节点**是 **其** 父节点的**左子树**，则返回当前节点父节点的父节点 `curNode.next.next` 
        - 比如当前节点为 5，则2 为 1 的左子树，则返回 1
      - 如果**当前节点的父节点** 是 **其** 父节点的**右子树**
        - 一直向上搜索，直到找到一个父节点是其父节点的左子树为止
          - 如果父节点不存在左子树，则说明当前节点是这个二叉树的最右节点，也是中序遍历的最后一个节点
        - 以（1) 7 举例，5 是 2 的右子树，则继续寻找5 的父节点 2
          - 2 为 1 的左子树，返回 1
        - 以(1) 3 举例，1 是 0 的左子树，返回 0

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E4%BA%8C%E5%8F%89%E6%95%B0%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9.png" width = "500"/>
</center>



### 对称的二叉树

> 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。

#### 题目解法

对同一棵树进行两次扫描，第一次使用前序遍历，第二次使用逆序的前序遍历

即，第一次从左侧开始扫描，为了防止所有元素都一样的情况，对 None 节点也要进行处理

```python
if pRoot is None:
    self.preorder.append('#')
    return
self.preorder.append(pRoot.val)
self.PreorederTraversal(pRool.left)
self.PreorderTraversal(pRool.right)
```

第二次则从右侧开始扫描

```python
if pRoot is None:
    self.inverse_preorder.append('#')
    return
self.inverse_preorder.append(pRoot.val)
self.PreorderTraversal(pRool.right)
self.PreorederTraversal(pRool.left)
```

然后比较两者的列表是否一样





### 按照之字形打印二叉树

> 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。

#### 自己的解法

需要三个数组：

- `permanent` 记录最终的之字形打印的顺序
- `cur_layer` 记录当前层的节点
- `next_layer` 记录由当前层的节点添加的下一层节点，顺序与当前层相反

需要一个标记：

- left_right: 如果 > 0 则表示当前层的顺序为从左到右打印，如果小于 0 则表示当前层为从右到左



#### 递归解法

使用递归，不仅同时进行了先序遍历，并且从左到右存储了每一层的节点值

以下述二叉树为例，进行说明

- 初始化 `final_sequence = []`
- 初始化层数为 1
- 如果当前层数 > `len(final_sequence)` ,则对最终列表进行扩充
  - 比如当前 层数为 1，但是列表大小为 0，则扩充列表成为 `[[]]`
- 从列表中提取比当前层数 - 1 的子列表，将当前节点的值添加
  - 初始节点为 5，初始层数为 1，则当前列表为 `[[]]`，提取子列表 [0]，得到[]，将 5 添加，则列表为 [[5]]
- 进行递归

```python
self.Preorder(depth + 1,pRoot.left)
self.Preorder(depth + 1, pRoot.rigt)

```



<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%92%E5%BD%92.png" width = "600"/>
</center>





### 序列化二叉树

> 请实现两个函数，分别用来序列化和反序列化二叉树
>
> 二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）
>
> 二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。

#### 题目解法

程序按照前序遍历的方法对二叉树进行序列化以及重构，当遇到根节点时，添加 `!` ，遇到左儿子或者右儿子为空时，添加 `#`

以下图二叉树为例，前序遍历序列化的结果为 `[5,3,1,!,4,!,7,9,!,10,!]`

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%92%E5%BD%92.png" width = "600"/>
</center>

##### 序列化重构

需要注意的是，要 **明确** 当前处理的是哪一个节点。

在进行递归时，处理的节点为当前指向的节点，以及指向节点的左儿子和右儿子

当前序列的字符不为 `!` 和 `#` 时，构建节点。

- 如果当前序列字符为 `!` 则表明当前节点为根节点，直接返回。
- 如果当前序列字符为 `#`，则跳过构建节点的步骤





### 二叉搜索树中第 k 小的节点

> 给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。

#### 题目解法

以下述二叉搜索树举例，求第 k 小的节点

因为二叉搜索树按照左大右小的顺序进行排列，所以**中序遍历**之后的结果，即为节点从小到大的结果

下图中序遍历结果为 `[2,3,4,5,6,7,8]`



<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%AC%ACk%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9.jpg" width = "250"/>
</center>

### 数据流的中位数

> 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。

#### 题目解法

##### 各种解法性能分析



<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.jpg" width = "700"/>
</center>



##### 利用 AVL 树



##### 利用最大堆和最小堆

如下图所示，当前数据为素数时，指针为同一个位置，当当前数据长度为偶数时，则指针指向两个不同的位置

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.jpg" width = "700"/>
</center>

利用最大堆最小堆思想

- 建立一个最大堆，存储上图中`P1` 左边的数据
- 建立一个最小堆，存储上图中 `p2` 右边的数据

**有以下问题需要解决：**

- 保证最大堆最小堆只相差一个数据
  - 当新进入一个数据，如果当前数据的总数为`奇数`， 则插入最大堆
  - 当新进入一个数据，如果当前的数据总数为`偶数`，则将数据插入最小堆
- 保证最大堆的所有数据要小于最小堆的数据
  - 当需要将数据插入最大堆时，先将数据插入最小堆
    - 对最小堆进行数据插入操作
    - 然后对最小堆进行删除操作，提取最小堆的最小元素
    - 将最小堆的最小元素插入最大堆
  - 当需要将数据插入最小堆时，先将数据插入最大堆
    - 对最大堆进行数据插入操作
    - 对最大堆进行删除操作，提取最大堆的最大元素
    - 将最大堆的最大元素插入最小堆

经过以上操作，则可以保证，最大堆保存的所有元素全部小于最小堆的元素，且最大堆与最小堆最多只相差一个元素。注意，最大堆最小堆存在岗哨，所以数据从  1 开始



对以上操作进行数据模拟，顺序输入数据 $[2,3,7,6,9,10]$

- 输入2

当前数据长度为 1，奇数，插入最大堆。先将数据插入最小堆，取得最小堆最小值 2，插入最大堆
$$
最大堆:[2] ~~~~最小堆：[]
$$
如果此时要求返回，则返回最大堆[1]，注意存在岗哨，数据从 1 开始 

- 输入 3 

当前数据长度为 2，偶数，插入最小堆。先将数据插入最大堆，取得最大堆最大值，3，插入最小堆
$$
最大堆:[2] ~~~~最小堆：[3]
$$
中位数为 : float(最小堆[1] + 最大堆[1]/2.0)

- 输入 7

当前数据长度为 3，奇数，插入最大堆。先插入最小堆，取得 3，插入最大堆
$$
最大堆:[2,7] ~~~~最小堆：[3]
$$
依次类推





### 滑动窗口的最大值

> 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。

#### 自己的想法

根据题目的描述进行模拟，每次在 K 个数据中寻找最大值，一共寻找 O(n) 次。则时间复杂度为 O(KN)

#### 队列解法

利用队列存储滑动窗口目前最大值的**下标**，以及**可能成为最大值**的下标

以下列数组举例
$$
[2,3,4,2,6,2,5,1]
$$

##### 如何定义可能成为最大值

假设当前队列中只有第一个值是 2，则如果数组进来的下一个值若是**大于** 2，则 2 在任何一个滑动窗口内也不可能为最大值，如果进来的下一个值小于 2，则滑动窗口划出 2 时，这个小于 2 的值就有可能成为最大值

- 首先处理构建第一个滑动窗口的元素

  - 对每一个元素都进行入队列的操作

  - ```python
    while self.index and num[self.index[0]] <= num[i]:
    	self.index.pop()
    self.index.append(i)
    ```

- 从位置为 size 的元素开始添加max元素

  - 与上述判断一样，只向队列中添加可能为最大值的元素下标，如果当前元素大于最后元素，则从后删除所有不可能的元素

  - 需要判断当前队列最前端的值是否仍在滑动窗口内

    - ```python
      if self.index[0] <= (i-size):
      	self.pop(0)
      ```

    - 以 $[2,3,4,2,\underbrace{6,2,5},1]$ 举例，

      - 如果当前滑动到最后一个元素 1 $[2,3,4,2,6,\underbrace{2,5,1}]$，则 1的位置为 7,7 - size(3)  = 4，而 6 的位置为 4，说明超出当前的滑动窗口，对 6 进行删除



### 矩阵中的路径

> 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串"bcced"的路径，但是矩阵中不包含"abcb"路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。

#### 题目解法

利用 `DFS` 或者 `BFS` 对矩阵进行搜索，如果当前节点所在的路径不符合条件，则需要回退回上一节点，此时对标记矩阵进行回退



### 机器人的运动范围

> 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？

#### 题目解法

利用搜索，`DFS` 或者`BFS` ，但是需要添加判定条件，如果行列位数之和大于 k 则当前格子不进行搜索，直接跳过



#### 剪绳子

> 给你一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n>1并且m>1），每段绳子的长度记为k[0],k[1],...,k[m]。请问k[0]xk[1]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

#### 题目解法

使用动态规划或者贪心

##### 动态规划

使用动态规划需要建立数组当前绳子长度的最大值，比如 `self.max_product[3]` 表示在绳子长度为 3 的情况下的最大值（包含剪绳子以及不剪绳子），则当绳子长度为 4 的时候，可以搜索 `self.max_product[1]``self.max_product[3]` | `self.max_product[2]``self.max_product[2]`

并取最大值

##### 贪心

- 当绳子长度为 4 时，分为 2 和 2 长度最大，为 4

- 当绳子长度为 5 时，分为 2 和 3 为 6

- 当绳子长度为 6 时，

  - 1 和 5 的情况乘积为6
  - 2 和 4 的情况乘积为 8
  - 3 和 3 的情况为 9

- 绳子长度为 7 时，

  - 1 和 6 的情况乘积为 9
  - 2 和 5 为 12 (2,2,3）
  - 3 和 4 为 12 (2,2,3)

- 绳子为 8

  - 1 和 7 为 12
  - 2 和 6 为 18 (2,3,3)
  - 3 和 5 为18 (3,2,3)
  - 4 和 4 为 16

  则当绳子为 大于等于 5 时，多减 3 的长度，然后剩下的为 1 或者 2，相乘得到最大值

