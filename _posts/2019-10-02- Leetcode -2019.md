---
layout:     post   				    # 使用的布局（不需要改）
title:      Leetcode 解题记录 				# 标题 
subtitle:   data structure           #副标题
date:       2019-10-02 				# 时间
author:     WYX 						# 作者
header-img: img/5.9.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - data structure

---



# Leetcode 解题记录

## 状态压缩

#### 5337 寻找元音字母出现偶数次的最长子串

以 `leetc` 为例，在默认情况下，满足的子串为 0 ，长度也为 0。

使用一个 5 元元组对 `aeiou` 各个原因字母的出现情况进行表示

- ```python
  res = [0,0,0,0,0] # 表示 a,e,i,o,u
  dic[(0,0,0,0,0)] = -1 # 对 (0,0,0,0,0) 进行长度初始化
  for length,term in enumerate(s):
      if term in vowel:
  		res[vowel[term]] ^= 1
      dis[res] = length
  ```

- 上述中使用异或，因为异或操作遇到偶数次相同的数字为 0 

- 此时 dic 数组记录的就是不同原因字母状态的最大长度（从 0 开始）

  - 最大长度意思是，`leetc` 中 `(0,0,0,0,0)` 的状态在 0 的长度下满足，在 1 的位置下也满足，在 4 的位置下也满足，此处记录的就是 4

记录：从数组开头，到当前位置下，5 元元组的情况

记录完成后，再从头遍历一次数组，这一步是要为每种不同的状态找到一个起始点，如果从开头可以找到一个与当前存储在 `dis` 数组中相同的状态

- 说明除却当前位置的元素，到 `dis` 记录的那个状态为止，这一子串是满足条件的
- 长度计算为 `dis[res] - length`

以 `leeteminicowo`举例

到最后一个元素 o ，第一次遍历记录的 `0,1,0,0,0` 下标为 12

第二次遍历到第一个 `e` 的位置，遇到相同状态 `0,1,0,0,0` 此时表示从 `e` 的下一个位置开始到末尾，这一子串符合条件

> 初始情况设为 dic[0,0,0,0,0] = -1 

是为了解决从头开始的子串长度与不从头开始的子串长度计算不一致

以 `leetco` 举例

- (0,0,0,0,0) 状态下记录的下标为 4，实际长度为 5
- 计算子串长度时，比如从第一个 e 到第一个 c，直接下标相减即可
  - 到c的实际长度为 `index[c] + 1`，到 e 的实际长度为 `index[e] + 1`，两者相减 1 抵消
- ans 初始化为 (0,0,0,0,0) 的长度 + 1
  - 此时若不将 dic[(0,0,0,0,0)] 初始化为 -1，若遇到 `i` 这种字符的情况，则出现错误

## 递归

#### 面试题 19 正则表达式匹配

> 难点在于对所有的情况进行分析

分析时，主要聚焦在 pattern 部分，先分析 s 或 p 有一个为空或者均为空的情况

- 若 s 和 p 均为空，则表示为 `true`
- 若 p 为空，s 不为空
  - 则为 `False`
- 若 s 为空
  - 如果当前  p 长度  > 1，且 `p[1] == '*'`，则继续进行递归
  - 否则 False
- 如果 s 和 p 均不为空
  - 首先分析 p 存在 `*` 的情况
    - 如果当前元素不等，且 `p[0] != .` 时，直接跳过 ‘*’ 元素
    - 否则若当前元素相等，或者 `p[0] == '.'` 时，两种情况同样处理
      - 跳过 p 的 '*' 元素，s 不动
      - s 匹配，p 不动
        - s 匹配，p 动的情况被上述情况包含，所以不用考虑



## 数位

#### 320 列举单词的缩写

**解法**

使用二进制对不同的状态进行表示，比如
$$
0： 0000 \rightarrow 表示 word 不进行压缩 \\
\space \\
0001 \rightarrow 表示 1ord \\
0010 \rightarrow w1rd \\
0110 \rightarrow w2d
$$
一共有 $2^n$ 种可能，状态表示也就从 0 - $2^n-1$ 

- 每次对当前数字判断末尾是否为 0，若为 0 ，则保留当前字母，并处理上一个不为零的 `cnt`
  - 注意此时状态的二进制表示与 word 是反着来的
  - w 对应 二进制的最后一位，o 对应倒数第二位
- 若当前状态为1，则 `cnt +1`
- 要注意处理全为 1 的情况，所以跳出循环后还要判断 `cnt` 是否为 0

#### 171 Excel 表列序号

考察进制的概念，以 'AAA' 为例

**解法1**

> 从后向前

一共存在 26 个英文字母，则本题为 26 进制，逢 26 进 1，将其转化为十进制，则从最后一位开始
$$
AAA = 1*26^2+1*26^1+1*26^0 \\
\space\\
ZY = 26*26^1+25*26^0
$$
**解法2**

> 从前向后

进制转换的计算也可以从前向后计算，以 10 进制的 2019 举例
$$
2019 = 2*10^3 + 0 * 10^2 + 1 * 10^1 + 9 * 10^0 \\
\space \\
将上式提取 10 \\
\space \\
\Rightarrow 10 \times (10 \times ( 10 \times (2 + 10 \times 0)+0)  + 1) + 9
$$
给定 `num = 0`， 则可以从 2 开始计算

#### 168 Excel 表列名称

> 难点在于，A-Z 从 1 开始计数，而非 0

如果按照一般的十进制转 26 进制计算，会有问题，因为 0 不表示任何字母，且从 A 到 Z 向 10 进制转换时， 加了 1。

在从 十进制转回来的时候，每次 n 需要 - 1

## 循环找规律

#### 1103 分糖果

假设一共 3 个人，糖果数字为 11，则分配如下

| 1    | 2    | 3    |
| ---- | ---- | ---- |
| 4    | 1    |      |

**解法1**

模拟分发糖果的过程

```python
dis = [0] * n
i = 0
while candie:
    dis[i%n] += i+1
    candie -= i
    i += 1
    # 如果下一次循环时，糖果数目不够或者刚好，则下一次为最后一次
    if candie <= i:
        dis[i%n] += candie
        break
```

**解法2**

可以直接求解出**除最后一次分发糖果外**，一共进行了多少次的分发，设该数字为 `p`



> 等差数列求和公式如下

$$
S = \frac{n(a_1 + a_n)}{2} = na_1 + \frac{d}{2}n(n-1)
$$

----

设总糖果数目为 `C` ，最后一次分发的剩余糖果为 `remain`
$$
remain = C - \frac{p(1+p)}{2}
$$
且最后一次分发有如下限制
$$
0\leq C - \frac{p(1+p)}{2} < p + 1
$$
利用二次方程的求根公式以及 `p` 为整数的限制可以直接求得 p
$$
-2C \leq -p - p^2 < 2(p+1-C) \\
\space \\
\Rightarrow -2p-2+C < p^2 + p \leq 2C
$$
Note:

`p` 为除最后一次分发外，分发的总次数，当数字为 3，且糖果数为 10 时，分发在 4 结束，但是 `p` 为 4，表示下一次分发为 0

因为处最后一行外，每一列的分发也呈等差数列，所以可以完整分发的行数，以及最后一行剩余的列数，然后对数组直接求解

## 堆

#### 253 会议室 II

**解法1**

- 将区间按照开始时间从小到大排列
- 按照顺序，将区间的结束时间插入最小堆
- 每次遇到一个新区间，先检查堆顶的元素是否 **小于等于** 该新区间的开始时间
  - 若小于等于，则取出堆顶元素
    - 并插入新区间的结束时间
  - 若不小于等于
    - 直接插入新区间的结束时间

遍历完区间之后，堆的大小即为需要的会议室数量

**解法2**

同样遍历区间，但是对开始时间以及结束时间同时排序，以 `num` 记录最大的会议室数量

- 如果遇到开始时间，则 `num += 1` 表示需要开一间会议室
- 如果遇到结束时间，则 `num -= 1` 表示一间会议室可以关闭

最后 `num` 的最大值即为所需要的最大会议室数量

## 字符串

#### 165 比较版本号

**解法**

将给定版本号根据 `.` 进行分割

```python
string_list = version.split('.')
```

将每一个list 转换为整数进行比对

**注意：**

注意版本号长度不对应的情况，以 `1.1.1` 和 `1.1` 举例

上述前两个分割相同，在第三个分割处，第一个版本号存在 1 第二个版本号没有，则第二个版本默认为 0

此时继续转换第一个版本号，若其不为 0 ，则 返回 1，否则返回 0

- 上述要注意 `1.1.0` 以及 `1.1` 的情况，此种情况下两者相同

#### 7 逆转整数

**解法**

不使用栈或数组进行逆序，利用 `%` `//` 等操作模拟 `pop` 以及 `push` 操作，以下假定 `x` 为输入整数

```python
res = 0
while x:
	pop = x %10 #模拟 pop 操作
	x //= 10
	# 模拟 push 操作
	res = res * 10 + pop
```

 最终返回 res

题目给定的整数区间为 32 进制 $[-2^{31},2^{31}-1]$

则先将 x 取绝对值，将上述整数区间也取绝对值，若在计算中 `res` 大于 bound，则返回  0。最后根据 x 的正负号对 `res` 取正负号

**解法**

遍历给定字符串的同时建立一个字典。`键` 为对当前字符串进行排序的结果，`值`为所有排序结果相同的字符串组成的链表

**返回**

返回字典的值

```python
return lookup_dict.values()
```

#### 13 罗马字母转换

**解法**

利用字典存储相应的值，遍历字符串时优先考虑可以组成对的字符串（即优先考虑当前位置和当前位置 + 1的字符是否符合 subtraction 的情况）



## 栈

#### 155 最小栈

问题的核心在于对栈元素的返回

- 如何在当前最小元素被 `pop` 之后，返回第二小的栈元素

**解法1**

建立两个栈，一个`数据栈`随机记录数据，一个 `最小栈` 记录栈的最小值

- 只有当`数据栈` `push` 的元素小于`最小栈`的栈顶元素时
  - 将该元素同步 `push` 到`最小栈`
- 当 `数据栈`当前 `pop` 元素与最小栈顶元素相同时
  - 同步 `pop` 最小栈栈顶元素

**解法2**

使用一个`数据栈`以及 `self.min` 同时完成栈数据压入以及最小元素的查找问题

- 使用 `self.min` 记录当前最小值
- 若新进元素小于 `self.min`, 首先将 `self.min` 压入`数据栈`
- 将新进元素压入 `数据栈`

当遇到 `pop` 操作时

- 若当前 `pop` 元素与 `self.min` 相等时，
  - 先弹出当前元素，当前元素的下一个元素即为 `self.min` 的更新值
  - 弹出下一元素
- 若弹出当前元素后，`数据栈` 为空则将 `self.min` 设为 None

Note:

`self.min` 初始值为 None，遇到第一个元素时，直接更新

#### 103 之字形打印树

**解法**

根据题目描述，使用两个栈存储节点，当两个栈均为空时，跳出循环

- 若第一个栈存在节点，则从后往前跳出
  - 跳出同时使用第二个栈对其孩子进行堆栈（从左到右）
  - 同时将跳出节点的 val 添加进行最终打印的列表中
- 若第二个栈存在节点，从后往前跳出
  - 使用第一个栈对其孩子进行堆栈（从右到左）

两个栈同时只会有一个不为空

#### 20 有效的括号

**解法**

**检测是否存在非法输入**

根据题目描述，合法输入仅为括号。使用 正则表达式 检测是否有非括号的非法输入

**使用栈检测括号输入是否合法**

- 遇到左边括号 `[,{,(` 将其压入堆栈
- 遇到右手边括号 `],},)` 将栈顶元素弹出，检测是否为相应的左边括号，如果不是返回 False
  - 如果此时栈空，则返回 False

若检测结束，栈中仍然有元素，返回 False

## 链表

#### 234 回文链表

**要点**

如何找到链表的中间节点，当链表数为奇数时，中间节点为正中间的数；当链表长度为偶数时，中间节点为平分节点数的最后一个节点
$$
1 \rightarrow 2 \rightarrow 3 \rightarrow 4: 中间节点 2 \\
\space \\
1 \rightarrow 2 \rightarrow 3 \rightarrow 4 \rightarrow 5:中间节点为 3
$$


- 使用快慢指针，慢指针走一步，快指针走两步
- 当快指针判定跳出时，慢指针指向中间节点

```
if fast.next and fast.next.next:
```

将后半部分节点翻转，与前半部分节点比较，然后将链表复原

#### 160 相交链表

求两个链表的第一个交点

**解法**

- 首先确定两个链表的长度
- 将长的链表现向前移动，直到两个链表长度一致
- 同时移动两个链表，并进行比对

#### 445 两数之和2

**解法**

利用两个栈，首先遍历两个链表，分别将链表的值推入两个栈中，利用先进后出，从后往前构建节点

- 构建当前节点时，只存储两个链表值的余数

```python
res = ListNode(sum%10)
```

- 构建上一节点的初始值

```python
head = ListNode(sum //=10)
```

- 将两个节点连接，并进行迭代

```python
head.next = res
head = res
```

#### 141 环形链表

**解法1**

只利用一个指针遍历链表，利用一个字典存储遍历过的链表节点，如果遇到相同的节点则返回 `True`

**解法2**

利用快慢指针，当快指针追上慢指针时表示链表中存在环形节点

- 若快指针或者满指针任意一个指针到达 None，则表示链表中不存在环形节点

#### 成对翻转链表节点

**解法1：递归**

递归终止条件为

下述述条件表示，当只剩下一个节点或者没有节点时，直接返回

```python
if not head or not head.next:
	return 
```

递归只有在当前的 `head` 以及 `head.next `不为空时才进行

```python
first = head
second = head.next

first = self.swap(second.next)
second.next = first

return second
```

**解法2：建立 guard 使用迭代**

首先为 head 建立一个岗哨，目的为返回头结点

```python
guard = Listnode(-1)
guard.next = head
```

进行迭代需要当前 `head`以及 `head.next` 不为空，也就是存在两个节点

```python
while head and head.next:
	first = head
    second = head.next
    # 开始交换
    pre = second
    first.next = second.next
    second.next = first
    
    #更新
    pre = first
    head = first.next
```

#### 最近最少使用缓存机制 LRU

**解法**

使用字典+双向链表的方法进行完成，要求如下

- 给定键，在 O(1) 时间内查找相应的值，如果不存在则返回 -1，此次操作为 get 操作

  - 若该键存在，其操作顺序如下
    - 根据该键，访问字典，字典中存储的为该键值节点的地址
    - 根据该地址，访问该节点
    - 将该节点的从双向链表中断开
      - 将该节点上节点与下节点相连
    - 将该节点插入 `self.head.next` 
    - 返回该节点的 value

- 写入键值对，如果当前已有的键值对为最大容量  (capacity) ，则删除最近最少使用的键值对

  > get 操作视为对已有键值对的一次访问，如果写入键值对时，该键仍然存在，则该写入仍然视为对该键值对的一次访问
  >
  > 在删除时，直接删除 `self.tail.prev` 的节点，因为每次访问节点时，都会将最新的节点插入到 `self.head` 之后

  - 删除最近最少使用键值对
  - 如果键不存在，则在 `slef.head` 后面插入新的键值节点
    - 在字典中建立 `键:节点`的对应关系

#### 列表翻转

**链表翻转前 K 个节点**

与全部链表翻转的情形相同，翻转前 K 个如下
$$
1\rightarrow2\rightarrow3\rightarrow4\rightarrow None \\
\space \\
3\rightarrow2\rightarrow1\rightarrow4\rightarrow None
$$
回忆列表翻转的递归形式

```python
if not head or not head.next:
    # 如果当前为一个节点，或者当前节点为 None,则不进行翻转
    return head
right = self.reverse(head.next)
head.next.next = head
head.next = None #将链表翻转过后，1 成为尾部，尾部连接 None

```

翻转前K个需要改动判定条件，以及尾部的链接

```python
# 翻转前 K 个链表最终返回头结点
if n == 1:
    successor = head.next
    return head
right = self.reverse(head.next,n-1)
head.next.next = head.next
head.next = successor
```

**翻转某一个区间的链表**

与翻转前 K 个链表相结合，首先找到要翻转的起始节点，然后调用翻转前 K 个链表



---

给定下述一个链表，进行翻转
$$
1\rightarrow2\rightarrow3\rightarrow4\rightarrow None
$$

**迭代方法**

定义两个变量 `left` 和 `right` 分别从头 (1) 开始，left 指向 1，right 指向2,

- 断开 left 与 right 之间的链接
- 记录 right 指向的 next
- 将 right 的 next 指向 left
- 向右移动 left 和 right
  - left 变为 right
  - right 变为 记录下来的 right.next

**递归方法**

迭代方法从头开始，递归方法从末尾开始，也就是 3 和 4 开始，其中递归的判定条件如下

```python
def reverseList(self, head):
    if not head or not head.next:
        return head
    right = self.reverseList(head.next)
    head.next.next = head
    head.next = None
    return right
```

当递归开始返回时，head 指针指向 3，right 指向 4

Note: 

- 此处 right 仅代表从右开始的 head，其本身不参与链表断开与重连

  - 指向 4 的 right 会一路返回至最初的递归
  - 断开与重连由下述代码完成

  ```python
  head.next.next = head
  head.next = None
  ```

#### 复制带随机指针的链表

**解法1:**

使用字典存储

> 缺点：需要额外的空间进行存储链表节点的字典

遍历两遍

- 第一遍遍历根据原始链表建立新的链表，但是不复制其随机指针
  - 建立字典，存储键为 **原始链表节点的地址**
  - 存储值为 **对应新链表节点的地址**
- 第二遍遍历根据字典，对新链表的随机节点进行赋值

**解法2：**

在每个原始节点后面添加一个新的节点

遍历三遍，假设原始链表如下，其中() 中表示random 节点
$$
1(null) \rightarrow 2(1) \rightarrow 3(2)
$$

- 第一遍遍历，在当前原始节点上建立新的节点然后添加

$$
1(null) \rightarrow 1()\rightarrow 2(1)\rightarrow2() \rightarrow 3(2)\rightarrow3()
$$

- 第二遍遍历，根据原始节点的 random 指针，对新建立的节点的指针进行 random 赋值
- 第三遍遍历，断开原始节点与新建立节点的指针



## 其他

#### 914 卡牌分组

**解法**

N 个数的最大公约数如何计算

假设给定一个序列如下
$$
[1,2,3,4]
$$


- 最后一个数与之前所有的数的 gcd
- 倒数第二个数与之前所有的数的 gcd

```python
gcdN(self,nums):
	if len(nums) == 1:
        return nums[0]
   	return gcd(nums[-1],gcdN(nums[0:-1]))
```

最终开始返回的时候是 

```python
gcd(2,1)
>>>
gcd(3,gcd(2,1))
```

#### 348 判断井字棋胜负

**解法**

抽象想象 `TicTacToe` 类为棋盘，两个玩家有以下几种胜利方法

棋盘初始化为 `n x n` 的 0 矩阵

- 任意一行加和为 n
- 任意一列加和为 n
- 左对角线加和为 n
- 右对角线加和为 n