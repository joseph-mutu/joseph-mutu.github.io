---
layout:     post   				    # 使用的布局（不需要改）
title:      Leetcode 解题记录 				# 标题 
subtitle:   data structure           #副标题
date:       2019-10-02 				# 时间
author:     WYX 						# 作者
header-img: img/5.9.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - data structure

---



# Leetcode 解题记录

## 链表

#### 列表翻转

给定下述一个链表，进行翻转
$$
1\rightarrow2\rightarrow3\rightarrow4\rightarrow None
$$

##### 迭代方法

定义两个变量 `left` 和 `right` 分别从头 (1) 开始，left 指向 1，right 指向2,

- 断开 left 与 right 之间的链接
- 记录 right 指向的 next
- 将 right 的 next 指向 left
- 向右移动 left 和 right
  - left 变为 right
  - right 变为 记录下来的 right.next

##### 递归方法

迭代方法从头开始，递归方法从末尾开始，也就是 3 和 4 开始，其中递归的判定条件如下

```python
def reverseList(self, head):
    if not head or not head.next:
        return head
    right = self.reverseList(head.next)
    head.next.next = head
    head.next = None
    return right
```

当递归开始返回时，head 指针指向 3，right 指向 4

Note: 

- 此处 right 仅代表从右开始的 head，其本身不参与链表断开与重连

  - 指向 4 的 right 会一路返回至最初的递归
  - 断开与重连由下述代码完成

  ```python
  head.next.next = head
  head.next = None
  ```

#### 复制带随机指针的链表

##### 解法1:

使用字典存储

> 缺点：需要额外的空间进行存储链表节点的字典

遍历两遍

- 第一遍遍历根据原始链表建立新的链表，但是不复制其随机指针
  - 建立字典，存储键为 **原始链表节点的地址**
  - 存储值为 **对应新链表节点的地址**
- 第二遍遍历根据字典，对新链表的随机节点进行赋值

##### 解法2：

在每个原始节点后面添加一个新的节点

遍历三遍，假设原始链表如下，其中() 中表示random 节点
$$
1(null) \rightarrow 2(1) \rightarrow 3(2)
$$

- 第一遍遍历，在当前原始节点上建立新的节点然后添加

$$
1(null) \rightarrow 1()\rightarrow 2(1)\rightarrow2() \rightarrow 3(2)\rightarrow3()
$$

- 第二遍遍历，根据原始节点的 random 指针，对新建立的节点的指针进行 random 赋值
- 第三遍遍历，断开原始节点与新建立节点的指针



## 数组相关

#### 5 最长回文子序列

##### 传统解法

选中中心点进行扩展，如果两边字母一样，则两边同时向外增加，左边 -- ，右边 ++ 

###### 难点

- 选定中心扩展时，选取的中心不仅是字符串中的字符，还有字符串中的空格
  $$
  c~b~a~b~c
  $$

  - 给定上述字符串，中心为$c，\#(空格),b,\#(空格),a,\#(空格),b,\#(空格),c,\#(空格)$
  - 具体不同在于扩展时给定的左右字符不同
    - 中心为字符时，以第一个c举例，其` expandAroundCenter` 的 Left 和 Right 为 $i,i$，其中 i 为 c 的 index，也就是 0
    - 中心为字母是，以第一个 c 右边的空格举例，其 `expandAroundCenter` 的 Left 和 Right 分布为 $i,i+1$ ，其中 i 为 c 的 index，也就是 0

- 给定中心 index，给定距离，计算 start
  - $start = i - int(\frac{len-1}{2})$
  - $end = i  + int(\frac{len}{2})$

遍历所有的中心点，记录最大的回文长度

#### 两数相加

> 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
>
> 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
>
> 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
>
> 示例：
>
> 输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
> 输出：7 -> 0 -> 8
> 原因：342 + 465 = 807

##### 难点：

- 注意需要进位的情况以及在链表头添加一个 head 节点、
- 注意判断最后一次头结点相加时的进位，也就是 4 + 6 变为 0 -> 1

> 假设按照升序排序的数组在预先未知的某个点上进行了旋转。
>
> ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。
>
> 请找出其中最小的元素。
>
> 你可以假设数组中不存在重复元素。
>
> 示例 1:
>
> 输入: [3,4,5,1,2]
> 输出: 1
> 示例 2:
>
> 输入: [4,5,6,7,0,1,2]
> 输出: 0

### 解法

- 使用两个指针，一个指针永远指向第一个没有进行旋转的数组

  - 第二个指针指向被旋转部分的数组

  - ```
    while right - left > 1
    ```

- 使用 mid 判断 mid 当前在没旋转的数组中还是被旋转的数组中

  - ```python
    		while right - left > 1:
      			mid = int((left+right)/2)
      
      			if nums[mid] >= nums[right]:
      				# mid is in the first array
      				left = mid
      			else:
      				right = mid
    ```

    

注意考虑特殊情况，没有旋转的数组也算是旋转数组（旋转为 0）

```python
if nums[left] > nums[right]:
	reutrn nums[left]
```

### 从前序与中序遍历序列构造二叉树

> 根据一棵树的前序遍历与中序遍历构造二叉树。
>
> 注意:
> 你可以假设树中没有重复的元素。
>
> 例如，给出
>
> 前序遍历 preorder = [3,9,20,15,7]
> 中序遍历 inorder = [9,3,15,20,7]
>
> 返回一棵二叉树

#### 解法：

递归求解，每次递归只完成一个值的赋值。

- 从前序遍历，取出其首数字，该数字为**当前二叉树**的根节点
- 在中序遍历中定位达到该数字
  - 该数字向左，均为**当前根节点**的左子树
  - 该数字向右，均为**当前根节点**的右子树
- 计算左子树长度: `left_length = mid_pos - mid_start`
- 计算右子树长度: `right_length = length - left_length - 1`
- 为当前二叉树赋值，`cur_node = TreeNode(preorder[preStart])`
- 循环求解
  - `cur_node.left = buildNode(left)`
  - `cur_node.right = buildNode(right)` 

Note:

当当前长度为  0 时，返回 None

当当前长度为 1 时，建立新的节点，并将新节点赋给当前节点



> 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。
>
> 说明：解集不能包含重复的子集。
>
> 示例:
>
> 输入: [1,2,2]
> 输出:
> [
>   [2],
>   [1],
>   [1,2,2],
>   [2,2],
>   [1,2],
>   []
> ]

#### 解法

首先注意，数组包含重复元素，但是不保证数组为顺序，所以首先对数组进行排序

使用非递归解法，如果当前数字与上一个数字重复，则只对新添加的元素进行处理。

以示例举例,开始 res 只包含一个空集，即[[]]，以 `pre_num` 表示上一个循环的数字，`pre_len` 表示上一个循环时的 res 长度

- 输入 1 
  - `pre_num` = 1， `pre_len` = 1
  - res 包含[],[1]
- 输入 2,
  - 2 不等于 `pre_num`
  - 更新 `pre_num = 2,pre_len = 2`
  - 则从头开始循环 res
  - res 包含 [],[1],[2],[1,2]
- 输入 2
  - 2 与 `pre_num` 相等
  - 更新 `pre_num = 2,pre_len = 4`
  - 从 `pre_len` 开始循环 res 数组，也就是从 `[2]` 开始
  - res 包含[],[1],[2],[1,2],[2,2],[1,2,2]

### 合并两个有序数组

> 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。
>
> 说明:
>
> 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。
> 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。
>
> 示例:
>
> 输入:
> nums1 = [1,2,3,0,0,0], m = 3
> nums2 = [2,5,6],       n = 3
>
> 输出: [1,2,2,3,5,6]

#### 解法

从后往前开始处理第一个数组，在 `cur_pos >=0 and pos1 >= 0 and pos2 >=0` 三个条件下跳出

- 处理跳出条件，如果 pos1 >= 0 或者 cur_pos 为 0 跳出，无需处理直接返回
- 如果 pos2 >= 0，表示数组 2 剩下元素没有处理，将数组 2 剩下元素全部复制到数组1 中

### 柱状图中最大的矩形

> 给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
>
> 求在该柱状图中，能够勾勒出来的矩形的最大面积。
>
> ```python
> 输入: [2,1,5,6,2,3]
> 输出: 10
> ```

#### 解法

利用单增栈，当当前数字大于栈顶元素时，**开始处理栈顶元素**，即弹出计算其面积，以上述 [2,15,6,2,3] 举例

首先给栈中添加  - 1，为了便于处理第一个进栈元素；为了处理 Height 数组中的最后一个元素，对 height 数组中的末尾添加 -1

则当前两个数组为 `stack = [-1], Height = [2,1,5,6,2,3,-1]`,res 记录当前的最大矩形面积

如果当前元素大于栈顶元素，则将元素的下标入栈

- 判断 2，2 大于 栈顶元素 -1，则将 2 的下标 idx 0 入栈，stack = [-1,0]
- 1 小于栈顶元素 2，则处理栈顶元素 2
  - 从 stack 中弹出 2
  - 计算 2 的矩形宽度，使用当前元素的下标（ **也就是1的下标** ） - stack [ -1] (2 被弹出，此时计算的就是 -1) - 1
  - 矩形宽度为 1，矩形面积为 2，res = 2
- 入栈 1 
- 5 大于 1，入栈
- 6 大于  5，入栈
- 2 小于 6，开始处理 6，6 x1 = 6
  - 处理 5,5 x 2 = 10, res = 10
- 入栈 2，入栈 3，-1 小于 3，处理3
- 3 x 1 = 3
- **2 x 4 = 8**, 当前 的 idx = 6，弹出 2 后，stack 栈顶元素为 1，其下标为 1,6 - 1 - 1 = 4
  - 符合题目，因为从 2 画矩形，除了 1 ，5,6,2,3 4 个矩形都可以包括
- 相应的 1 矩形的面积为 6。因为其左元素 2 之前已经弹出，所以当处理到 1 的时候，stack 栈顶元素为 -1. 6 - -1 + 1 = 6.

<img src="C:\Users\mutudeh\AppData\Roaming\Typora\typora-user-images\image-20191207071715898.png" alt="image-20191207071715898" style="zoom:25%;" />

### 搜索旋转排序数组 2

> 假设按照升序排序的数组在预先未知的某个点上进行了旋转。
>
> ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。
>
> 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。
>
> 示例 1:
>
> 输入: nums = [2,5,6,0,0,1,2], target = 0
> 输出: true
> 示例 2:
>
> 输入: nums = [2,5,6,0,0,1,2], target = 3
> 输出: false

#### 解法：

**与简单的旋转排序数组方法一致，唯一的区别在于数组当中可能存在重复值**

- 设定两个指针，一个 left 指向数组开头，一个 right 指向数组结尾
- 每次取 mid 值
  - 如果 mid 等于 target，返回
  - 如果 mid 值小于 right 值，则表示包含 mid 的右半段为有序
    - 如果 mid 小于等于 target 且 最右大于等于 target，此时 left = mid + 1 
    - 否则 right = mid - 1
  - 如果 mid 值大于 right 值，则表示包含 mid 的左半段为有序
    - 如果 mid 大于等于 target 且 最左小于等于 target，此时 right = mid - 1
    - 否则 left = mid + 1
  - 如果 mid 值等于 right 值，则表示数组包含重复数字，此时将 right 向右移

### 删除排序数组中的重复项 2

> 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
>
> 示例 1:
>
> 给定 nums = [1,1,1,2,2,3],
>
> 函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。

#### 解法1

定义两个指针，一个为 slow 一个为 fast，还有一个计数器 count = 1

- 因为每个元素最多出现两次，也就是 `nums[slow] == nums[fast]` 出现一次，cnt -= 1
  - 当 cnt 为 0 时，表示超出规定，需要删除

当 `nums[slow] == nums[fast] and cnt == 0` 时表示

- 两数相等，但是超出规定出现两次的限制，所以 `fast += 1`, slow 原地不动

当`nums[slow] == nums[fast]` 但是 `cnt != 0` 时表示

- 两数相等，但是没有超出规定限制，所以 `slow += 1` 并且 `fast += 1`
- 对元素进行替换

当 `nums[slow] != nums[fast]` 时表示

- 两数不同，此时需要对元素进行替换
- 先对 slow += 1
- `nums[slow] = nums[fast]`
- fast += 1
  - 因为 slow 表示的是，需要替换的位置的前一个数

#### 解法2

从头开始遍历数组，定义一个位置变量 pos，代表当前需要替换的位置

- 如果 pos < 2时，num 直接替代 nums[pos]，且 pos += 1
- 当 当前遍历的数 num 大于 nums[pos-2] 时，进行替换，否则只循环 num



### 单词搜索

> 给定一个二维网格和一个单词，找出该单词是否存在于网格中。
>
> 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
>
> 示例:
>
> board =
> [
>   ['A','B','C','E'],
>   ['S','F','C','S'],
>   ['A','D','E','E']
> ]
>
> 给定 word = "ABCCED", 返回 true.
> 给定 word = "SEE", 返回 true.
> 给定 word = "ABCB", 返回 false.

#### 解法

深度优先或者广度优先进行搜索

### 颜色分类

> 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
>
> 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
>
> 注意:
> 不能使用代码库中的排序函数来解决这道题。
>
> 示例:
>
> 输入: [2,0,2,1,1,0]
> 输出: [0,0,1,1,2,2]

#### 解法：

利用两个指针对数组进行排序，排序从小到大

- 一个 start 指向数组开头，用以表示当前第一个不为 0 的位置
- 一个 end 指向数组末尾，用以表示第一个不为 2 的位置

从头开始遍历数组，如果当前值为 0，则当前 i 值与 start 所指向的元素交换，且 start ++

如果当前值为 2，则当前 i 值与 end 所指向元素交换，且 end --，i --

如果为 1 则继续，不做任何处理



### 搜索二维矩阵

> 编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：
>
> 每行中的整数从左到右按升序排列。
> 每行的第一个整数大于前一行的最后一个整数。

#### 解法

利用两次二分搜索该 target

- 第一次二分搜索 target 可能存在的行，搜索第一个大于 target 的数，然后回退

  - ```python
    while left < right:
    	update mid
    	if mid <= target:
    		left = mid +1
    	else:
    		right = mid
    return right
    ```

  - 如果 right 返回为 0 ，则不需回退

- 第二次搜索，搜索该target，如果找到target，返回 True，否则返回 False

### 矩阵置零

>  给定一个 *m* x *n* 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用**[原地](http://baike.baidu.com/item/原地算法)**算法**。** 	
>
> 输入: 
> [
>   [1,1,1],
>   [1,0,1],
>   [1,1,1]
> ]
> 输出: 
> [
>   [1,0,1],
>   [0,0,0],
>   [1,0,1]
> ]

#### 解法：

- 首先利用两个 bool 值记录第一行以及第一列中是否存在 0，row_zero, col_zero
- 遍历除第一行第一列之外的矩阵，如果当前值为 0 ，则对应的第一行的值以及第一列的值设为 1，这一步是为了记录 0 的位置。
  - 为什么不在找到 0 的时候直接将一行和一列置为 0 ，因为直接将该值所在行以及列置为 0 ，如果该行或者该列其他位置也存在 0 ，则会造成错误
- 再次扫描除第一行以及第一列之外的矩阵，如果对应的第一行**或者**第一列中存在  0， 则将该位置置为 0 
- 如果 row_zero, 为 0 ，将第一行置为 0 
- 如果col_zero 为 0 ，将第一列置为 0

### 加一

> 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。
>
> 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
>
> 你可以假设除了整数 0 之外，这个整数不会以零开头。
>
> ```python
> 输入: [1,2,3]
> 输出: [1,2,4]
> 解释: 输入数组表示数字 123。
> ```

#### 解法：

两种方法：

- 先将数组转换为数字，再将数字 + 1，再转化为数组进行输出
- 直接对数组进行操作
  - 从后向前进行判断，遇到第一个不为 9 的数字，+ 1 返回
  - 如果前面没有返回，则对第一个数字进行判断，如果第一个数字为 9 ，则变为 0 ，且在前面插入 0 
    - 如果第一个数字不为 9，则 + 1 返回

### Two Sum

> 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
>
> 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
>
> 给定 nums = [2, 7, 11, 15], target = 9
>
> 因为 nums[0] + nums[1] = 2 + 7 = 9
> 所以返回 [0, 1]

#### 解法1：

- 从头开始遍历数组

- 建立一个字典存储，其中 `键` 为每一个遍历过的数字，`值` 为该数字相应的下标

- 每遍历到一个新数字的时候，进行判断

  - ```python
    if self.dict.get(target - nums[i]) is None
    ```

  - 若为 None，则表示之前遍历过的数组中没有与其组成 target 的数

- 若不为 None，则返回



### 26. 删除排序数组中的重复值

> 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
>
> 给定数组 nums = [1,1,2], 
>
> 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 
>
> 你不需要考虑数组中超出新长度后面的元素。
>

#### 不需要改变整个数组

题目要求返回修改后数组的前新长度的数字

- 可以直接修改数组的前 m 个数字，假设 m 为数组中不重复的数字

#### 如何统计数组中不重复的数字

利用两个指针，初始化位置为 0

- 当两个指针指向的位置相同，快指针向前移动
- 当两个指针指向的位置不同，两个指针一起移动

返回的数字为慢指针的当前位置 + 1（因为初始化位置为 0）



### 三数之和

> 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。
>

#### 思路

最后的输出存在要保证三个性质：

- 加和为 0
- 输出顺序
- 三元组无重复

##### 加和为 0 且输出顺序

首先将输入数组排序，利用三个指针，分为 `left` `mid` `right` ，保证 left 永远指向最小的数，mid 为 left 的下一个数，right 为最右边的数。每次固定 `left` 则该问题变为 `2Sum` 问题。即 mid 与 right 之和为 0 - nums[left]

##### 三元组无重复

因为输入数组排序，每次 left 遇到重复的数字则直接进行跳过，mid 与 right 进行同样的操作



### 最接近的三数之和

> 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。
>
> 例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.
>
> 与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).
>

#### 思路

与三数之和的思路一致，只不过要找最接近的。定义一个当前最小，并且实时对当前答案进行更新即可



### 四数之和

> 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

#### 思路

利用三数之和的思想

- 第一次固定第一个值

  - 固定第二个值，注意，每次第一个值更新之后，第二个值的初始位置都要进行更新
    - 利用夹逼法则，利用两个指针进行扫描数组的前后




### 移除元素

> 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
>
> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
>
> 示例 1:
>
> 给定 nums = [3,2,2,3], val = 3,
>
> 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
>
> 你不需要考虑数组中超出新长度后面的元素。
>

#### 思路

使用两个指针，两个指针初始都指向数组的头，也就是 0 位置。

- cur_pos 指针用来代表当前位置的元素
- judge 指针的位置永远大于等于 cur_pos，用以判断下一个元素是否等于给定的 val 值

如果judge 位置的元素不等于给定的 val 值，则将judge 位置的元素赋值给 cur_pos 的指针的位置，且 judge +1 以及 cur_pos + 1

如果 judge 位置的元素等于给定的 val 值，则仅将 judge + 1



### 下一个排列

> 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
>
> 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
>
> 必须原地修改，只允许使用额外常数空间。
>
> 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
> 1,2,3 → 1,3,2
> 3,2,1 → 1,2,3
> 1,1,5 → 1,5,1

- 从后往前找到第一个逆序对
  - 第一个数和前面的所有数比对，如果没有，第二个数和前面所有的数进行比对
- 找到逆序对，交换位置，设为 i,j (i > j)
- 记住 i 的位置，将 i 之后的所有元素逆序



### 在排序数组中查找元素的第一个和最后一个位置

> 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
>
> 你的算法时间复杂度必须是 O(log n) 级别。
>
> 如果数组中不存在目标值，返回 [-1, -1]。
>
> 示例 1:
>
> 输入: nums = [5,7,7,8,8,10], target = 8
> 输出: [3,4]
> 示例 2:
>
> 输入: nums = [5,7,7,8,8,10], target = 6
> 输出: [-1,-1]

#### 解法：

利用二分法进行搜索，因为目标为整数数组，则利用二分法搜索 target - 0.5 以及 target + 0.5 的值

##### 注意：

需要注意二分法跳出的步骤，在搜索 - 0.5 以及 + 0.5 时，判断循环跳出的步骤为

```python
while left <= right:
	执行
return left
```

在上述情况下，

- 当搜索 -0.5 时，left 返回的是第一个数组中的值，如果不存在该值，则返回 -1
- 当搜索 + 0.5 时，left 返回的是最后一个该 target 的值，如果该值不存在，则有可能返回越界值，此时需要判断



### 35. 搜索插入位置

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
>
> 你可以假设数组中无重复元素。
>
> 示例 1:
>
> 输入: [1,3,5,6], 5
> 输出: 2
> 示例 2:
>
> 输入: [1,3,5,6], 2
> 输出: 1
> 示例 3:
>
> 输入: [1,3,5,6], 7
> 输出: 4
> 示例 4:
>
> 输入: [1,3,5,6], 0
> 输出: 0

#### 解法：

使用二分法进行搜索

- 如果当前值存在于数组中，则就是简单地二分法

- 如果当前值不存在与数组之中，

  - 如果 target 小于数组中的某一个元素（也就是target可以插入在数组中间），则返回的则是第一个大于该target的值

  - ```python
    while left <= right:
    	执行
    	if nums[mid] == target:
    		return mid
    rturn left
    ```

  - 如果 target 大于数组中的所有元素则返回的则是越界的数字位置，也就是 `len(nums)`



### 组合总和

> 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
>
> candidates 中的数字可以无限制重复被选取。

#### 解法：

递归进行求解：

- 有三个参数需要传入递归搜索当中
  - cur_ans, ans, target
  - 其中 cur_ans 代表当前解，ans 代表所有可能的解，target 代表当前解距离真实 target 还差多少



### 组合总和2

> 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
>
> candidates 中的每个数字在每个组合中只能使用一次。
>
> - 所有数字（包括目标数）都是正整数。
> - 解集不能包含重复的组合。 

与上述有所不同，因为数字中不保证无重复，所以可以存在重复元素如 $[10,1,2,7,6,1,5]$ 

对数组进行排序后，进行递归搜索，如何避免重复的组合

```python
for i in range(cur_pos,len(data)):
	if i != cur_pos and data[i-1] == data[i]:
		continue
```

以上述数组举例
$$
[1,1,2,5,6,7,10]
$$
第一个 1 存在一个解 $[1,2,5]$

当循环到第二个 1 时，因为其不是该循环的初始值，（初始值为第一个1），且与其前一个值相等，表示当前值与之前值会存在相同的解空间，所以直接跳过





### 旋转图像

> 给定一个 n × n 的二维矩阵表示一个图像。
>
> 将图像顺时针旋转 90 度。
>
> 说明：
>
> 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。
>
> 给定 matrix =
> [
>   [ 5, 1, 9,11],
>   [ 2, 4, 8,10],
>   [13, 3, 6, 7],
>   [15,14,12,16]
> ], 
>
> 原地旋转输入矩阵，使其变为:
> [
>   [15,13, 2, 5],
>   [14, 3, 4, 1],
>   [12, 6, 8, 9],
>   [16, 7,10,11]
> ]

#### 解法

难点在于确定交换数据的坐标值

- 使用两层循环，外圈每一次循环对矩阵的每一圈完成旋转的操作，到 $\frac{n}{2}$ 为止
- 内圈到 $len(data) - 1 - i$ 为止

以上述 4 x 4 矩阵举例，这是内圈的操作，内圈的一次循环对 4 个位置进行相似的循环，(0,0),(0,1),(0,2),(0,3) 即完成最外圈的旋转操作

-  $(0,0) \rightarrow (0,3)$
- $ (0,3) \rightarrow (3,3)$
- $ (3,3) \rightarrow (3,0)$
- $ (3,0) \rightarrow (0,0)$



###  最大子序和

> 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
> 示例:
>
> 输入: [-2,1,-3,4,-1,2,1,-5,4],
> 输出: 6
> 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6

两个需要注意的点：

- 如何定义系统最小值

  - ```python
    fin_min = float('-inf')
    import sys
    fin_min = -sys.maxsize()-1
    ```

- 如何在负数情况下，进行最大子序和

  - 在全为正数的数组中，可以使用

    - ```python
      if tem_sum <0:
      	tem_sum = 0
      ```

  - 在包含负数的数组中，

    - ```python
      tem_sum += cur_data
      tem_sum = max(tem_sum,cur_data)
      ```

      

#### 分治法

停止条件：

- 当子数组中只剩一个数字的时候，则返回该数字，即 `left = right`

分支法求取子数组的最大值分为三个部分，以中间值为划分：

- 左半边的最大值
- 右半边的最大值
- 从中间向左右两边延伸的最大值

以 $[-2,1,-3,4]$ 举例，中间值为 1，左半边为 $[-2,1]$, 右半边为$[-3,4]$

- 跨越边界的值为，
- 从 1 向左延伸，包含每一个向左的数字（不能断开）的最大值
- 从 -3 开始，向右延伸，包含每一个向右的数组，不得断开，的最大值
- 两者相加即为跨越边界的最大值





### 顺时针打印矩阵（螺旋矩阵）

> 给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。
>
> 示例 1:
>
> 输入:
> [
>  [ 1, 2, 3 ],
>  [ 4, 5, 6 ],
>  [ 7, 8, 9 ]
> ]
> 输出: [1,2,3,6,9,8,7,4,5]
> 示例 2:
>
> 输入:
> [
>   [1, 2, 3, 4],
>   [5, 6, 7, 8],
>   [9,10,11,12]
> ]
> 输出: [1,2,3,4,8,12,11,10,9,5,6,7]

#### 解法

按照顺时针方向打印矩阵，每次打印的起始点在矩阵的对角线上 ： $(0,0),(1,1),(2,2),\ldots $

- 打印停止的条件：`start *2 < column and start * 2 < rows`

打印分为4步走：

- 打印第一行，只要打印不停止，总是需要打印第一行
- 打印最后一列（打印到最后可能就剩下一列，这时候打印第一行就是打印第一个数，然后向下打印）
  - 有限制条件，需要`end_row > start`, 也就是当前的行数要大于 start
- 打印最后一行，存在限制条件，需要当前至少为 2 行 2 列
  - `end_row > start and end_col > start`
- 打印第一列，存在限制条件，需要至少为 3 行 2 列
  - `end_row - 1 > start and end_col > start`

### 螺旋矩阵2

> 给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。
>
> 示例:
>
> 输入: 3
> 输出:
> [
>  [ 1, 2, 3 ],
>  [ 8, 9, 4 ],
>  [ 7, 6, 5 ]
> ]

#### 解法

与顺时针打印矩阵相同，区别在于每次螺旋遍历矩阵的时候不进行打印，**而是填入数字**

**Note**:

- 每次循环要对 start 以及 `end_col` `end_row` 进行更新

### 跳跃游戏

> 给定一个非负整数数组，你最初位于数组的第一个位置。
>
> 数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
> 判断你是否能够到达最后一个位置。
>
> 示例 1:
>
> 输入: [2,3,1,1,4]
> 输出: true
> 解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
> 示例 2:
>
> 输入: [3,2,1,0,4]
> 输出: false
> 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。

#### 解法：

##### 贪心算法：

每次保留当前位置所能到达的最远距离，如果其大于最终的数组长度，表示可到达数组尾端，否则则不能

##### 动态规划：

利用动态规划数组节省时间，数组保存到达当前位置时，还剩下的最大跳力，递推公式如下
$$
dp[i] = max(dp[i-1],nums[i-1]) - 1
$$



### 56. 合并区间

> 给出一个区间的集合，请合并所有重叠的区间。
>
> 示例 1:
>
> 输入: [[1,3],[2,6],[8,10],[15,18]]
> 输出: [[1,6],[8,10],[15,18]]
> 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
> 示例 2:
>
> 输入: [[1,4],[4,5]]
> 输出: [[1,5]]
> 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。

#### 解法：

- 将列表进行排序
  - 列表排序时，会先按照第一个数字进行排序，如果第一个数字相同再按照第二个数字的大小进行排序
- 从第一个区间开始遍历
  - 存在三种情况，下一个区间完全与第一个不重叠，此时判断下一个区间的开始数字以及第一个区间的结束数字即可确定
  - 下一个区间与第一个区间部分重叠
  - 下一个区间与第一个区间完全重叠
    - 后两种情况可以使用同一种方法进行判别
    - 保留原始区间的起始值，终点值在原来的终点值，以及下一个区间的终点值之间取 max



### 57. 插入区间

> 给出一个*无重叠的 ，*按照区间起始端点排序的区间列表。
>
> 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。
>
> 示例 1:
>
> 输入: intervals = [[1,3],[6,9]], newInterval = [2,5]
> 输出: [[1,5],[6,9]]
> 示例 2:
>
> 输入: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
> 输出: [[1,2],[3,10],[12,16]]
> 解释: 这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。

#### 解法

对区间进行合并，分为三步

- 寻找第一个与新区间存在交集的区间，

  - ```python
    while cur < length and intervals[cur][1] < newInternvals[0]:
        do something
        cur += 1
    ```

  - 当循环跳出时，cur 即为第一个有重叠的区间

- 找到 cur 的位置，寻找所有与新区间存在交集的区间，需要进行合并

  - ```python
    while cur < length and intervals[cur][0] < newIntervals[1]:
    	newIntervls[0] = min(internvas[cur][0],newIntervals[0])
        newIntervls[1] = max(internvas[cur][1],newIntervals[1])
    ans.append(newIntervals)
    ```

- 添加所有剩余区间



### 62. 不同路径

> 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
>
> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
>
> 问总共有多少条不同的路径？
>
> ```
> 输入: m = 3, n = 2
> 输出: 3
> 输入: m = 7, n = 3
> 输出: 28
> ```

#### 解法：

##### 递归

每次探索一个向左或向右的可能性

##### 动态规划

建立一个二维数组，数组的第一行第一列均为 1 ，dp[i] [j] 表示当前位置一共有多少种可能，其具有如下递推关系
$$
dp[i][j] = dp[i-1][j] + dp[i][j-1]
$$
更新数组，最后返回 $dp[i-1][j-1]$

##### 组合数求解

移动到最终目的一共需要 m+n - 2步(m-1 + n -1)，则问题可以视为
$$
C_{m+n-2}^{m-1} = C_{m+n-2}^{n-1}
$$



### 不同路径 2

> 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
>
> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
>
> 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
>
> 输入:
> [
>   [0,0,0],
>   [0,1,0],
>   [0,0,0]
> ]
> 输出: 2
> 解释:
> 3x3 网格的正中间有一个障碍物。
> 从左上角到右下角一共有 2 条不同的路径：
> 1. 向右 -> 向右 -> 向下 -> 向下
> 2. 向下 -> 向下 -> 向右 -> 向右
>

#### 解法：

适用动态规划，但是对初始化有一些限制，且适用动态规划的时候，如果该位置在原始数组中为 1，则 $dp[i][j] = 0$

- 如果初始位置即为 1 ，则直接返回 0

对第一行第一列初始化如下：


$$
dp[0][0] = 1, if~ obstacle[0][0] != 1 \\
\space \\
第一行：dp[0][i] = dp[0][i-1], if~ obstacle[0][i] != 1 ~else~ 0 \\
\space \\
第一列：dp[i][0] = dp[i-1][0], if~ obstacle[i][0] != 1~ else~ 0
$$




### 最小路径和

> 给定一个包含非负整数的 *m* x *n* 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
>
> **说明：**每次只能向下或者向右移动一步。

#### 解法：

在进行初始化的时候，对第一行，第一列初始化如下
$$
dp[0][0] = grid[0][0] \\
\space \\
第一行：dp[0][i] = dp[0][i-1] + grid[0][i-1] \\
\space \\
第一列：dp[i][0] = dp[i-1][0] + grid[i][0]
$$


同样适用动态规划，只对递推公式有小的更改
$$
dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]
$$








## 图相关



### 克隆图

给定一个图，需要对其每个节点，每条边进行克隆，分为深度优先和广度优先两种方法

建立 `Visit` 字典，其中 `键` 为原始图的节点，`值` 为相对应的克隆图的节点，对**原图的节点**进行遍历

- 如果原图的邻节点不在 `Visit` 字典中，说明该节点之前没有遇到过，需要进行克隆
  - 根据邻节点的值，创建一个新的节点 `Node(neighbor.val,[])`
  - 将该节点作为 `值` 添加到以邻节点作为`键` 的 `Visit` 字典中（也就是在 `Visit ` 中添加新的键值对）
  - 将**克隆节点的当前节点**的 [neighbors] 中添加该克隆节点
- 如果原图的邻节点在 `Visit` 字典中，说明该节点之前遍历过