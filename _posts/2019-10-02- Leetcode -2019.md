---
layout:     post   				    # 使用的布局（不需要改）
title:      Leetcode 解题记录 				# 标题 
subtitle:   data structure           #副标题
date:       2019-10-02 				# 时间
author:     WYX 						# 作者
header-img: img/5.9.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - data structure

---



# Leetcode 解题记录

## 数组相关

### Two Sum

> 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
>
> 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
>
> 给定 nums = [2, 7, 11, 15], target = 9
>
> 因为 nums[0] + nums[1] = 2 + 7 = 9
> 所以返回 [0, 1]

- 从头开始遍历数组

- 建立一个字典存储，其中 `键` 为每一个遍历过的数字，`值` 为该数字相应的下标

- 每遍历到一个新数字的时候，进行判断

  - ```python
    if self.dict.get(target - nums[i]) is None
    ```

  - 若为 None，则表示之前遍历过的数组中没有与其组成 target 的数

- 若不为 None，则返回



### 26. 删除排序数组中的重复值

> 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
>
> 给定数组 nums = [1,1,2], 
>
> 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 
>
> 你不需要考虑数组中超出新长度后面的元素。
>

#### 不需要改变整个数组

题目要求返回修改后数组的前新长度的数字

- 可以直接修改数组的前 m 个数字，假设 m 为数组中不重复的数字

#### 如何统计数组中不重复的数字

利用两个指针，初始化位置为 0

- 当两个指针指向的位置相同，快指针向前移动
- 当两个指针指向的位置不同，两个指针一起移动

返回的数字为慢指针的当前位置 + 1（因为初始化位置为 0）



### 三数之和

> 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。
>

#### 思路

最后的输出存在要保证三个性质：

- 加和为 0
- 输出顺序
- 三元组无重复

##### 加和为 0 且输出顺序

首先将输入数组排序，利用三个指针，分为 `left` `mid` `right` ，保证 left 永远指向最小的数，mid 为 left 的下一个数，right 为最右边的数。每次固定 `left` 则该问题变为 `2Sum` 问题。即 mid 与 right 之和为 0 - nums[left]

##### 三元组无重复

因为输入数组排序，每次 left 遇到重复的数字则直接进行跳过，mid 与 right 进行同样的操作



### 最接近的三数之和

> 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。
>
> 例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.
>
> 与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).
>

#### 思路

与三数之和的思路一致，只不过要找最接近的。定义一个当前最小，并且实时对当前答案进行更新即可



### 四数之和

> 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

#### 思路

利用三数之和的思想

- 第一次固定第一个值

  - 固定第二个值，注意，每次第一个值更新之后，第二个值的初始位置都要进行更新
    - 利用夹逼法则，利用两个指针进行扫描数组的前后




### 移除元素

> 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
>
> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
>
> 示例 1:
>
> 给定 nums = [3,2,2,3], val = 3,
>
> 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
>
> 你不需要考虑数组中超出新长度后面的元素。
>

#### 思路

使用两个指针，两个指针初始都指向数组的头，也就是 0 位置。

- cur_pos 指针用来代表当前位置的元素
- judge 指针的位置永远大于等于 cur_pos，用以判断下一个元素是否等于给定的 val 值

如果judge 位置的元素不等于给定的 val 值，则将judge 位置的元素赋值给 cur_pos 的指针的位置，且 judge +1 以及 cur_pos + 1

如果 judge 位置的元素等于给定的 val 值，则仅将 judge + 1



### 下一个排列

> 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
>
> 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
>
> 必须原地修改，只允许使用额外常数空间。
>
> 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
> 1,2,3 → 1,3,2
> 3,2,1 → 1,2,3
> 1,1,5 → 1,5,1

- 从后往前找到第一个逆序对
  - 第一个数和前面的所有数比对，如果没有，第二个数和前面所有的数进行比对
- 找到逆序对，交换位置，设为 i,j (i > j)
- 记住 i 的位置，将 i 之后的所有元素逆序



### 在排序数组中查找元素的第一个和最后一个位置

> 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
>
> 你的算法时间复杂度必须是 O(log n) 级别。
>
> 如果数组中不存在目标值，返回 [-1, -1]。
>
> 示例 1:
>
> 输入: nums = [5,7,7,8,8,10], target = 8
> 输出: [3,4]
> 示例 2:
>
> 输入: nums = [5,7,7,8,8,10], target = 6
> 输出: [-1,-1]

#### 解法：

利用二分法进行搜索，因为目标为整数数组，则利用二分法搜索 target - 0.5 以及 target + 0.5 的值

##### 注意：

需要注意二分法跳出的步骤，在搜索 - 0.5 以及 + 0.5 时，判断循环跳出的步骤为

```python
while left <= right:
	执行
return left
```

在上述情况下，

- 当搜索 -0.5 时，left 返回的是第一个数组中的值，如果不存在该值，则返回 -1
- 当搜索 + 0.5 时，left 返回的是最后一个该 target 的值，如果该值不存在，则有可能返回越界值，此时需要判断



### 35. 搜索插入位置

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
>
> 你可以假设数组中无重复元素。
>
> 示例 1:
>
> 输入: [1,3,5,6], 5
> 输出: 2
> 示例 2:
>
> 输入: [1,3,5,6], 2
> 输出: 1
> 示例 3:
>
> 输入: [1,3,5,6], 7
> 输出: 4
> 示例 4:
>
> 输入: [1,3,5,6], 0
> 输出: 0

#### 解法：

使用二分法进行搜索

- 如果当前值存在于数组中，则就是简单地二分法

- 如果当前值不存在与数组之中，

  - 如果 target 小于数组中的某一个元素（也就是target可以插入在数组中间），则返回的则是第一个大于该target的值

  - ```python
    while left <= right:
    	执行
    	if nums[mid] == target:
    		return mid
    rturn left
    ```

  - 如果 target 大于数组中的所有元素则返回的则是越界的数字位置，也就是 `len(nums)`



### 组合总和

> 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
>
> candidates 中的数字可以无限制重复被选取。

#### 解法：

递归进行求解：

- 有三个参数需要传入递归搜索当中
  - cur_ans, ans, target
  - 其中 cur_ans 代表当前解，ans 代表所有可能的解，target 代表当前解距离真实 target 还差多少







## 图相关

### 克隆图

给定一个图，需要对其每个节点，每条边进行克隆，分为深度优先和广度优先两种方法

建立 `Visit` 字典，其中 `键` 为原始图的节点，`值` 为相对应的克隆图的节点，对**原图的节点**进行遍历

- 如果原图的邻节点不在 `Visit` 字典中，说明该节点之前没有遇到过，需要进行克隆
  - 根据邻节点的值，创建一个新的节点 `Node(neighbor.val,[])`
  - 将该节点作为 `值` 添加到以邻节点作为`键` 的 `Visit` 字典中（也就是在 `Visit ` 中添加新的键值对）
  - 将**克隆节点的当前节点**的 [neighbors] 中添加该克隆节点
- 如果原图的邻节点在 `Visit` 字典中，说明该节点之前遍历过