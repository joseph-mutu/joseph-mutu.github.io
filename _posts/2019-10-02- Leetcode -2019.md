---
layout:     post   				    # 使用的布局（不需要改）
title:      Leetcode 解题记录 				# 标题 
subtitle:   data structure           #副标题
date:       2019-10-02 				# 时间
author:     WYX 						# 作者
header-img: img/5.9.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - data structure

---



# Leetcode 解题记录

## 数位

#### 171 Excel 表列序号

考察进制的概念，以 'AAA' 为例

**解法1**

> 从后向前

一共存在 26 个英文字母，则本题为 26 进制，逢 26 进 1，将其转化为十进制，则从最后一位开始
$$
AAA = 1*26^2+1*26^1+1*26^0 \\
\space\\
ZY = 26*26^1+25*26^0
$$
**解法2**

> 从前向后

进制转换的计算也可以从前向后计算，以 10 进制的 2019 举例
$$
2019 = 2*10^3 + 0 * 10^2 + 1 * 10^1 + 9 * 10^0 \\
\space \\
将上式提取 10 \\
\space \\
\Rightarrow 10 \times (10 \times ( 10 \times (2 + 10 \times 0)+0)  + 1) + 9
$$
给定 `num = 0`， 则可以从 2 开始计算

## 循环找规律

#### 1103 分糖果

假设一共 3 个人，糖果数字为 11，则分配如下

| 1    | 2    | 3    |
| ---- | ---- | ---- |
| 4    | 1    |      |

**解法1**

模拟分发糖果的过程

```python
dis = [0] * n
i = 0
while candie:
    dis[i%n] += i+1
    candie -= i
    i += 1
    # 如果下一次循环时，糖果数目不够或者刚好，则下一次为最后一次
    if candie <= i:
        dis[i%n] += candie
        break
```

**解法2**

可以直接求解出**除最后一次分发糖果外**，一共进行了多少次的分发，设该数字为 `p`



> 等差数列求和公式如下

$$
S = \frac{n(a_1 + a_n)}{2} = na_1 + \frac{d}{2}n(n-1)
$$

----

设总糖果数目为 `C` ，最后一次分发的剩余糖果为 `remain`
$$
remain = C - \frac{p(1+p)}{2}
$$
且最后一次分发有如下限制
$$
0\leq C - \frac{p(1+p)}{2} < p + 1
$$
利用二次方程的求根公式以及 `p` 为整数的限制可以直接求得 p
$$
-2C \leq -p - p^2 < 2(p+1-C) \\
\space \\
\Rightarrow -2p-2+C < p^2 + p \leq 2C
$$
Note:

`p` 为除最后一次分发外，分发的总次数，当数字为 3，且糖果数为 10 时，分发在 4 结束，但是 `p` 为 4，表示下一次分发为 0

因为处最后一行外，每一列的分发也呈等差数列，所以可以完整分发的行数，以及最后一行剩余的列数，然后对数组直接求解







## 动态规划

#### 322 兑换硬币

**解法**

`dp` 数组存储在 `amount` 的钱数下，所需要的最小硬币数

- 首先确定状态，什么为在当前问题以及子问题中持续变换的量

  - 目标钱数 amount

- 如果给定转移方程

  - ```python
    for coin in coins:
    	dp[amount] = min(dp[amount],1+dp[amount - coin])
    ```

- 从`amount = 1` 开始，其中 `dp[0] = 0`

- `dp[amount]` 除 0 外初始化为 `amount + 1`

#### 139 单词拆分

**暴力解法**

给定一个字符串，搜索所有可能的子串

```python
if start == len(string):
	return True
for end in range(start + 1,len(string) + 1):
    if string[start : end] in word_dict and self.check(end):
        return True
return False
```

- `string[start : end]` 以 end 为界限，end 之前的单词若存在于字典中，则继续判断 end 之后的单词

**暴力解法 + 记忆数组**

现对给定字符串 `aaab` 以及字典 `a,aa,aaa` 进行分析

- `start = 0, end = 1` 表示尝试第一个分界点在 1 处
  - `a` 存在于字典中，搜索 `aaab`, 此时 start = 1
    - `aaab` 返回 False，因为无论怎样切分都无法分割成字典中的单词
  - `end  = 2` ，`aa` 存在于字典中，搜索 `ab` 
    - 在第一次搜索 `aaab` 时，已经对 `ab`进行过求解，若不加存储，则仍然需要再次搜索

Note: 建立记忆化数组，存储从当前位置到末尾的求解结果，即

- memo[i] 表示 `i:len(string) + 1` 的搜索结果，为 True 或者 False

**动态规划**

建立动态规划数组，定义为从 `0:i-1` 这一段的子串是否可以被字典完全切割

`dp[0] = True` 为 Base case

- 判断时，根据切分点，分为dp数组并判断后一段是否存在于字典中

最后返回 dp 数组的最后一个值

## 搜索

#### 994 腐烂的橘子

**解法**

多元广度搜索，同时从多个点开始进行广度搜索，并记录当前位置距离其源点的路径长度

Note: 一个位置可以被多个不同的源点接触到，但是只取路径最小的一个值

在添加节点进入 `node_list` 时，同时添加 `dis` 变量表示从源点出发经过的距离

#### 22 生成括号

给定一个数字 `n`，要求给出 `n` 对括号所有可能的组合

**解法1**

利用深度优先搜索

- 每一个节点的值代表一个括号，可以是左括号，也可以是右括号
- 每一个节点中包含左边剩余的括号数，以及右边剩余的括号数
  - 如果要使生成的括号合法，则左边剩余的括号数要 `大于等于` 右边剩余的括号数
  - 否则剪枝
- 当左边剩余括号数以及右边剩余括号数均为 0 时，将当前路径添加进列表中，表示一种可能的组合



**解法2**

动态规划

- 建立 dp 字典，其中 `dp[i]` 包含给定 `i` 时所有可能的组合
  - `dp[0] = [[None]]`, `dp[1] = ["()"]`
- 考虑 `dp[i + 1]` 与之前 dp 数组的关系
  - 之前的括号只能存在于新进括号的里面或者外面，“（`dp[p]`）`dp[q]`” ，其中 `p+q = i`
- `dp[2]` 举例
  - dp[2] = "`(dp[0])dp[1]`" ，"`(dp[1])dp[0]`"
  - = "()()","(())"

## 堆

#### 253 会议室 II

**解法1**

- 将区间按照开始时间从小到大排列
- 按照顺序，将区间的结束时间插入最小堆
- 每次遇到一个新区间，先检查堆顶的元素是否 **小于等于** 该新区间的开始时间
  - 若小于等于，则取出堆顶元素
    - 并插入新区间的结束时间
  - 若不小于等于
    - 直接插入新区间的结束时间

遍历完区间之后，堆的大小即为需要的会议室数量

**解法2**

同样遍历区间，但是对开始时间以及结束时间同时排序，以 `num` 记录最大的会议室数量

- 如果遇到开始时间，则 `num += 1` 表示需要开一间会议室
- 如果遇到结束时间，则 `num -= 1` 表示一间会议室可以关闭

最后 `num` 的最大值即为所需要的最大会议室数量

## 字符串

#### 165 比较版本号

**解法**

将给定版本号根据 `.` 进行分割

```python
string_list = version.split('.')
```

将每一个list 转换为整数进行比对

**注意：**

注意版本号长度不对应的情况，以 `1.1.1` 和 `1.1` 举例

上述前两个分割相同，在第三个分割处，第一个版本号存在 1 第二个版本号没有，则第二个版本默认为 0

此时继续转换第一个版本号，若其不为 0 ，则 返回 1，否则返回 0

- 上述要注意 `1.1.0` 以及 `1.1` 的情况，此种情况下两者相同

#### 7 逆转整数

**解法**

不使用栈或数组进行逆序，利用 `%` `//` 等操作模拟 `pop` 以及 `push` 操作，以下假定 `x` 为输入整数

```python
res = 0
while x:
	pop = x %10 #模拟 pop 操作
	x //= 10
	# 模拟 push 操作
	res = res * 10 + pop
```

 最终返回 res

题目给定的整数区间为 32 进制 $[-2^{31},2^{31}-1]$

则先将 x 取绝对值，将上述整数区间也取绝对值，若在计算中 `res` 大于 bound，则返回  0。最后根据 x 的正负号对 `res` 取正负号

**解法**

遍历给定字符串的同时建立一个字典。`键` 为对当前字符串进行排序的结果，`值`为所有排序结果相同的字符串组成的链表

**返回**

返回字典的值

```python
return lookup_dict.values()
```

#### 13 罗马字母转换

**解法**

利用字典存储相应的值，遍历字符串时优先考虑可以组成对的字符串（即优先考虑当前位置和当前位置 + 1的字符是否符合 subtraction 的情况）

## 树

#### 235 二叉搜索树的最近公共节点

**解法**

因为是二叉搜索树，所以存在特性

- 左边的节点全部小于根节点
- 右边的节点全部大于根节点

最近公共节点的判定分为三种情况

- 如果 `p` 和 `q` 节点的值一个大于根节点一个小于根节点，则直接返回根节点

- 如果 `p` 和 `q` 节点均小于根节点，也就是都在左边

```python
LCS = self.lowestCommonNode(root.left,p,q)
```

- 如果 `p` 和 `q`节点均大于根节点，都在右边

```python
LCS = self.lowestCommonNode(root.right,p,q)
```

#### 二叉树的最近公共节点

**解法1**

使用 DFS 或者 BFS 先找出通往两个节点的路径，将两个路径存储。从一条路径的最后一个节点开始遍历，找到第一个同时存在于两个路径之间的节点，该节点即为公共节点

**解法2**

递归求解，分情况讨论

- 若 两个节点分属于 root 节点的两侧，则当前root节点即为返回节点
- 若两个节点全在与 root 节点的 左侧，则 

```python
left = self.lowestCommonAncestor(self,root.left,p,q)
```

left 返回左侧两个节点的 LCA 节点

```python
right = self.lowestCommonAncestor(self,root.right,p,q)
```

right 返回 None

- 若两个节点全在 root 节点的右侧，则

```python
left = self.lowestCommonAncestor(self,root.left,p,q)
```

left 返回 none

```
right = self.lowestCommonAncestor(self,root.right,p,q)
```

right 返回两节点的 LCA

总结为，若 left 不为 None，则返回 left，否则返回 right；若 left 和 right 同时不为 None，则返回 root

## 栈

#### 155 最小栈

问题的核心在于对栈元素的返回

- 如何在当前最小元素被 `pop` 之后，返回第二小的栈元素

**解法1**

建立两个栈，一个`数据栈`随机记录数据，一个 `最小栈` 记录栈的最小值

- 只有当`数据栈` `push` 的元素小于`最小栈`的栈顶元素时
  - 将该元素同步 `push` 到`最小栈`
- 当 `数据栈`当前 `pop` 元素与最小栈顶元素相同时
  - 同步 `pop` 最小栈栈顶元素

**解法2**

使用一个`数据栈`以及 `self.min` 同时完成栈数据压入以及最小元素的查找问题

- 使用 `self.min` 记录当前最小值
- 若新进元素小于 `self.min`, 首先将 `self.min` 压入`数据栈`
- 将新进元素压入 `数据栈`

当遇到 `pop` 操作时

- 若当前 `pop` 元素与 `self.min` 相等时，
  - 先弹出当前元素，当前元素的下一个元素即为 `self.min` 的更新值
  - 弹出下一元素
- 若弹出当前元素后，`数据栈` 为空则将 `self.min` 设为 None

Note:

`self.min` 初始值为 None，遇到第一个元素时，直接更新

#### 103 之字形打印树

**解法**

根据题目描述，使用两个栈存储节点，当两个栈均为空时，跳出循环

- 若第一个栈存在节点，则从后往前跳出
  - 跳出同时使用第二个栈对其孩子进行堆栈（从左到右）
  - 同时将跳出节点的 val 添加进行最终打印的列表中
- 若第二个栈存在节点，从后往前跳出
  - 使用第一个栈对其孩子进行堆栈（从右到左）

两个栈同时只会有一个不为空

#### 20 有效的括号

**解法**

**检测是否存在非法输入**

根据题目描述，合法输入仅为括号。使用 正则表达式 检测是否有非括号的非法输入

**使用栈检测括号输入是否合法**

- 遇到左边括号 `[,{,(` 将其压入堆栈
- 遇到右手边括号 `],},)` 将栈顶元素弹出，检测是否为相应的左边括号，如果不是返回 False
  - 如果此时栈空，则返回 False

若检测结束，栈中仍然有元素，返回 False

## 链表

#### 160 相交链表

求两个链表的第一个交点

**解法**

- 首先确定两个链表的长度
- 将长的链表现向前移动，直到两个链表长度一致
- 同时移动两个链表，并进行比对

#### 445 两数之和2

**解法**

利用两个栈，首先遍历两个链表，分别将链表的值推入两个栈中，利用先进后出，从后往前构建节点

- 构建当前节点时，只存储两个链表值的余数

```python
res = ListNode(sum%10)
```

- 构建上一节点的初始值

```python
head = ListNode(sum //=10)
```

- 将两个节点连接，并进行迭代

```python
head.next = res
head = res
```

#### 141 环形链表

**解法1**

只利用一个指针遍历链表，利用一个字典存储遍历过的链表节点，如果遇到相同的节点则返回 `True`

**解法2**

利用快慢指针，当快指针追上慢指针时表示链表中存在环形节点

- 若快指针或者满指针任意一个指针到达 None，则表示链表中不存在环形节点

#### 成对翻转链表节点

**解法1：递归**

递归终止条件为

下述述条件表示，当只剩下一个节点或者没有节点时，直接返回

```python
if not head or not head.next:
	return 
```

递归只有在当前的 `head` 以及 `head.next `不为空时才进行

```python
first = head
second = head.next

first = self.swap(second.next)
second.next = first

return second
```

**解法2：建立 guard 使用迭代**

首先为 head 建立一个岗哨，目的为返回头结点

```python
guard = Listnode(-1)
guard.next = head
```

进行迭代需要当前 `head`以及 `head.next` 不为空，也就是存在两个节点

```python
while head and head.next:
	first = head
    second = head.next
    # 开始交换
    pre = second
    first.next = second.next
    second.next = first
    
    #更新
    pre = first
    head = first.next
```

#### 最近最少使用缓存机制 LRU

**解法**

使用字典+双向链表的方法进行完成，要求如下

- 给定键，在 O(1) 时间内查找相应的值，如果不存在则返回 -1，此次操作为 get 操作

  - 若该键存在，其操作顺序如下
    - 根据该键，访问字典，字典中存储的为该键值节点的地址
    - 根据该地址，访问该节点
    - 将该节点的从双向链表中断开
      - 将该节点上节点与下节点相连
    - 将该节点插入 `self.head.next` 
    - 返回该节点的 value

- 写入键值对，如果当前已有的键值对为最大容量  (capacity) ，则删除最近最少使用的键值对

  > get 操作视为对已有键值对的一次访问，如果写入键值对时，该键仍然存在，则该写入仍然视为对该键值对的一次访问
  >
  > 在删除时，直接删除 `self.tail.prev` 的节点，因为每次访问节点时，都会将最新的节点插入到 `self.head` 之后

  - 删除最近最少使用键值对
  - 如果键不存在，则在 `slef.head` 后面插入新的键值节点
    - 在字典中建立 `键:节点`的对应关系

#### 列表翻转

给定下述一个链表，进行翻转
$$
1\rightarrow2\rightarrow3\rightarrow4\rightarrow None
$$

**迭代方法**

定义两个变量 `left` 和 `right` 分别从头 (1) 开始，left 指向 1，right 指向2,

- 断开 left 与 right 之间的链接
- 记录 right 指向的 next
- 将 right 的 next 指向 left
- 向右移动 left 和 right
  - left 变为 right
  - right 变为 记录下来的 right.next

**递归方法**

迭代方法从头开始，递归方法从末尾开始，也就是 3 和 4 开始，其中递归的判定条件如下

```python
def reverseList(self, head):
    if not head or not head.next:
        return head
    right = self.reverseList(head.next)
    head.next.next = head
    head.next = None
    return right
```

当递归开始返回时，head 指针指向 3，right 指向 4

Note: 

- 此处 right 仅代表从右开始的 head，其本身不参与链表断开与重连

  - 指向 4 的 right 会一路返回至最初的递归
  - 断开与重连由下述代码完成

  ```python
  head.next.next = head
  head.next = None
  ```

#### 复制带随机指针的链表

**解法1:**

使用字典存储

> 缺点：需要额外的空间进行存储链表节点的字典

遍历两遍

- 第一遍遍历根据原始链表建立新的链表，但是不复制其随机指针
  - 建立字典，存储键为 **原始链表节点的地址**
  - 存储值为 **对应新链表节点的地址**
- 第二遍遍历根据字典，对新链表的随机节点进行赋值

**解法2：**

在每个原始节点后面添加一个新的节点

遍历三遍，假设原始链表如下，其中() 中表示random 节点
$$
1(null) \rightarrow 2(1) \rightarrow 3(2)
$$

- 第一遍遍历，在当前原始节点上建立新的节点然后添加

$$
1(null) \rightarrow 1()\rightarrow 2(1)\rightarrow2() \rightarrow 3(2)\rightarrow3()
$$

- 第二遍遍历，根据原始节点的 random 指针，对新建立的节点的指针进行 random 赋值
- 第三遍遍历，断开原始节点与新建立节点的指针



## 数组

#### 402 移除 K 个数字变成最小数

题目关键在于如何移除 K 个数字

- 移除 K 个数字后，所有可能的数字都有一样的长度
  - 所以大小取决于开头的数字

以 546 举例

- 移除 4 为 56
- 移除 5  为 46
- 移除 6 为 54

从 第二位开始，如果当前位置比前一位小，则移除前一位

- 先 `append` 5，移动到 4
  - 如果不删除 5，则 5 开头，无论如何都不可能是最小的

> 假设数字为增序排列

如 
$$
123456
$$


则最小的即为前 K 个数字

> 注意删除之后有前置 0 ，比如 10200，删除完为 0200

使用 `lstrip(0)` 删除所有左 0

> 注意删除完之后，数字为空，此时返回 0

此处利用 `or` 操作

```python
0 and 10
>>> 0
0 or 10
>>> 10
```

#### 面试题 10.01 合并排序数组

给定两个排序数组，且第一个数组为第二个数组留有足够的位置，要求合并两个数组

两个数组从后向前遍历，定义一个元素，从第一个数组的最后空余位置开始向前遍历

- 若第一个数组 `end_A == -1` 说明第一个数组遍历完毕

```python
A[merge_end] = B[end_B]
end_B -= 1
```

-  若第二个数组 `end_B -= 1` 说明第二个数组遍历完毕，逐一将前面的数字替换为第二个数组的数字
- 若第一个数组当前元素大于等于第二个数组当前元素，则将后面填上第一个数组当前值
  - 否则，将后面填上第二个数组当前值

#### 寻找排列数组中的元素最小值

题目保证数组中没有重复的元素

利用双指针，使用二分查找，每次保证 `start` 指针指向旋转数组，`second` 指针指向排序数组

-  注意考虑将前 0 个元素旋转的情况，也就是没有旋转
- 若第一个元素小于等于最后一个元素，则直接返回第一个元素

当两个指针距离等于 1 时，返回 `second` 指针指向的元素 

#### 26 从排列数组中移除重复元素

**解法**

利用两个指针

- 当两个指针指向元素相同时，`second` 指针向前动
- 当两个指针指向元素不同
  - `first` 指针先向前移动
  - 将`second` 指针元素赋给 `first` 当前位置

最终 `first` 所在位置 + 1即为所有不同元素的个数。+1 是因为数组从 0 开始

#### 46 全排列 

**解法**

递归的过程中进行交换

```python
def permute(start):
    if start == len(nums):
        self.permutation.append(nums[:])
        
    for i in range(start,len(nums)):
        nums = swap(start,i)
        self.permute(start + 1)
        nums = swap(start,i)
```

以 `1,2,3` 进行分析，起始 `start` 为 0

- 刚开始 i 有 `0,1,2` 三个值可以迭代
  - `i = 0` ，与自己交换，等于没有操作，数组仍然为 `123`，再次进入递归 `start = 1`
    - 有 `1,2` 两个值可以迭代，`i = 1，start = 1`，与自己交换，等于没有操作，数组仍然为 `123`
      - 只有 1 个值可以迭代 `start = 2, i= 2`, 与自己交换，等于没有操作，进入递归
        - `start = 3` 与 length 相等，添加数组 `123` 返回 
      - 迭代终止，返回
    - 交换 `start = 1,i  = 1` 等于没有交换，
    - 第二次迭代`start = 1,i = 2` ，进行交换，数组为 `132` ，进入递归
      - `start = 2,i=2` 只有一个值可以迭代，自己与自己交换，等于没有操作
        - `start = 2 == len(nums) `， 迭代终止，添加数组 132
        - 返回
      - 迭代终止，返回
    - 迭代终止，返回
  - `start = 0,i=0`, 交换 `0,0` 位置，等于没有操作，继续迭代
  - `start = 0,i =1` ，进行交换，数组变为 `213`，进入迭代
    - `start = 1,i =1`
    - ...

#### 238 除自身以外的数组乘积

不可使用除法，输出一个数组，除自身以外的乘积

**解法**

`乘积 = 当前数字左边乘积 x 当前数字右边乘积`

- 建立左数组乘积，存储当前数字的左乘积
- 建立右数组乘积，存储当前数字的右乘积
- 将当前数字左右两边相乘，输出列表

Note: 第一个数字的左数组乘积为 1，最后一个数字的右数组乘积也为 1

**优化**

为了优化空间，可以直接在输出数组中进行左数组以及右数组乘积的运算

- 先遍历一遍列表，输出数组中存储左数组乘积
- 从后往前遍历，利用 R 存储右数组乘积，不断更新

#### 75 颜色排序

**解法**

进行三划分，定义不同区间，实现原地排序。题目中数组只包含 三个元素，要求实现三个元素的原地排序，且只能遍历一次数组

首先定义区间

- `[0,one_interval) = 0`
- `[one_interval,i)` = 1
- `[two:]` = 2

根据上述定义，当  i >= two_interval 时，退出循环

```python
当 i 为 0 时，交换 one_interval 与 i 的值
	i += 1
	one_interval += 1
当 i = 1 时
	i +=1 
else:
    two_interval -= 1
    swap(i,two_interval)
	
```



#### 48 旋转图像

**解法**

难点在于确定交换数据的坐标值

**Note: 在确定交换时的坐标时，把握住谁在变化，是行在变化还是列在变化**

- 使用两层循环，外圈 `i` 每一次循环对矩阵的每一圈完成旋转的操作，到 $\frac{n}{2}$ 为止
- 内圈到 $len(行长度) - 1 - i$ 为止

```python
for i in range(int(length/2)):
    for j in range(i,length - 1 - i):
        tem = matrix[i][j]
        matrix[i][j] = matrix[length - 1 - j][i]
        matrix[length - 1 - j][i] = matrix[length - 1 - i][length - 1 - j]
        matrix[length - 1 - i][length - 1 - j] = matrix[j][length - 1 - i]
        matrix[j][length - 1 - i] = tem
```

外圈 `i` 到 `int(length/2) ` 为止表示旋转时不用超过对角线

- 因为上述操作每次对一整圈进行旋转

#### 98 验证二叉搜索树

**解法**

使用递归分别验证根节点的左子树与右子树

- 为了保证左子树的所有节点均为小于根节点的值，需要添加一个 **upper_bound**
- 为了保证右子树的所有节点均为小于根节点的值，需要添加一个 **lower_bound**

#### 3 最长无重复子串

**解法**

使用 set 记录出现过的字符，使用 left 和 right 标识当前的子串长度，遍历字符串

- 每访问一个新的字符，right +1，标识当前长度加 1 

- 若当前字符曾在之前的字符串中出现过，将 left 不断向前移动，同时从 set 中删除相应的元素，直到当前字符为新字符为止
- 计算长度，并更新最大长度

#### 121 买卖股票的最佳时机

给定一个数组，求最大的差值，要求第一个数小，第二个数大

**解法**

遍历一次数组

```python
min_buy = sys.maxsize
max_prof = float('inf')
```

- 记录当前的最小值 

```python
min_buy = min(prices[i],min_buy)
```

- 对最大差值进行更新

```python
max_prof = max(max_prof, prices[i] - min_buy)
```

#### 17 电话号码的字母组合

**解法**

- 建立电话号码与其对应的字母的字典

- 按照给定的数字将相应的字母以列表的形式存储在一起

  - 假设输入为 "23"，则相应的存储为

  $$
  [['a','b','c'],['d','e','f']]
  $$

  

- 利用递归完成所有可能的排列组合

#### 33 在旋转数组中进行搜索

**解法**

- 根据中间数以及数组右边的数挑选出一定有序的一边
  - `nums[mid] < nums[right]`  表示 mid 数左边有序
  - 如果使用 数组最左边的数进行判断，则需要更改条件为 `nums[mid] >= nums[left]`
    - 对应情况为两个数的情况，假设数组为 $[8,0]$，target = 0
      - 则 left 为 8，right 为 0. 中间数为 8。若条件为 `nums[mid] > nums[left]`
      - 则当前条件不满足，则为 右边有序
      - 当判定到右边时，target 需要满足 `target >= nums[right] and target <= nums[mid]`
      - 此时 mid 为 8，右边 为 0，则判断失误，right 指针移到 left，return -1
      - 无法找到 0

- 利用有序的一遍判断 target 数值在中间数的左边还是右边

#### 8 字符串转换整数

给定一个字符串，判断是否为合法的可转换字符串，若合法则进行转换，否则返回 0。其中转换后整数需要在 $[2^{31} -1, -2^{31}]$ 范围内

**解法**

使用正则表达式以及 `string.lstrip()` 函数

- `string.lstrip()` 函数将消去输入字符串的全部左空格
- 使用正则表达式检测是否为合法字符串

###### 正则表达式

合法表达式需要满足如下规则

- 消去全部左空格之后，以正负号或者数字开头，下式为不符合规定的字符串，需要返回 0

$$
"words~ and~ 987"
$$

- 检测数字直到第一个不为数字的符号为止，下式返回 3

$$
3.141231231241
$$

相应的正则表达式如下

```python
p1 = r"[+-]?\d+"
pattern = re.compile(p1)
p1.match(string)
```

#### 151 Reverse Words in a String

给定一个句子，要求翻转其中单词顺序。如下
$$
"the~ sky ~is ~blue"  \rightarrow "blue~ is~ sky~ the"
$$

**解法**

- 首先对句子进行分解，使用 `string.split()` 方法，上述句子分离结果如下

$$
['the','sky','is','blue']
$$

​		其类型为列表

- 对该列表进行求逆
- 使用 " ".join() 函数进行拼接

#### 5 最长回文子序列

**传统解法**

选中中心点进行扩展，如果两边字母一样，则两边同时向外增加，左边 -- ，右边 ++ 

###### 难点

- 选定中心扩展时，选取的中心不仅是字符串中的字符，还有字符串中的空格
  
  
  $$
c~b~a~b~c
  $$
  
  
  
- 给定上述字符串，中心分别为 `c，(空格),b,(空格),a,(空格),b,(空格),c,(空格)`
  - 具体不同在于扩展时给定的左右字符不同
    - 中心为字符时，以第一个c举例，其` expandAroundCenter` 的 Left 和 Right 为 $i,i$，其中 i 为 c 的 index，也就是 0
    - 中心为字母是，以第一个 c 右边的空格举例，其 `expandAroundCenter` 的 Left 和 Right 分布为 $i,i+1$ ，其中 i 为 c 的 index，也就是 0
  
- 给定中心 index，给定距离，计算 start
  - $start = i - int(\frac{len-1}{2})$
  - $end = i  + int(\frac{len}{2})$

遍历所有的中心点，记录最大的回文长度

#### 两数相加

> 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
>
> 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
>
> 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
>
> 示例：
>
> 输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
> 输出：7 -> 0 -> 8
> 原因：342 + 465 = 807

**难点：**

- 注意需要进位的情况以及在链表头添加一个 head 节点、
- 注意判断最后一次头结点相加时的进位，也就是 4 + 6 变为 0 -> 1

**解法**

- 使用两个指针，一个指针永远指向第一个没有进行旋转的数组

  - 第二个指针指向被旋转部分的数组

  - ```
    while right - left > 1
    ```

- 使用 mid 判断 mid 当前在没旋转的数组中还是被旋转的数组中

  - ```python
    		while right - left > 1:
      			mid = int((left+right)/2)
      
      			if nums[mid] >= nums[right]:
      				# mid is in the first array
      				left = mid
      			else:
      				right = mid
    ```

    

注意考虑特殊情况，没有旋转的数组也算是旋转数组（旋转为 0）

```python
if nums[left] > nums[right]:
	reutrn nums[left]
```



## 其他

#### 348 判断井字棋胜负

**解法**

抽象想象 `TicTacToe` 类为棋盘，两个玩家有以下几种胜利方法

棋盘初始化为 `n x n` 的 0 矩阵

- 任意一行加和为 n
- 任意一列加和为 n
- 左对角线加和为 n
- 右对角线加和为 n