---
layout:     post   				    # 使用的布局（不需要改）
title:      Leetcode 解题记录 				# 标题 
subtitle:   data structure           #副标题
date:       2019-10-02 				# 时间
author:     WYX 						# 作者
header-img: img/5.9.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - data structure

---



# Leetcode 解题记录

## 数组相关

### Two Sum

> 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
>
> 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
>
> 给定 nums = [2, 7, 11, 15], target = 9
>
> 因为 nums[0] + nums[1] = 2 + 7 = 9
> 所以返回 [0, 1]

- 从头开始遍历数组

- 建立一个字典存储，其中 `键` 为每一个遍历过的数字，`值` 为该数字相应的下标

- 每遍历到一个新数字的时候，进行判断

  - ```python
    if self.dict.get(target - nums[i]) is None
    ```

  - 若为 None，则表示之前遍历过的数组中没有与其组成 target 的数

- 若不为 None，则返回



### 26. 删除排序数组中的重复值

> 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
>
> 给定数组 nums = [1,1,2], 
>
> 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 
>
> 你不需要考虑数组中超出新长度后面的元素。
>

#### 不需要改变整个数组

题目要求返回修改后数组的前新长度的数字

- 可以直接修改数组的前 m 个数字，假设 m 为数组中不重复的数字

#### 如何统计数组中不重复的数字

利用两个指针，初始化位置为 0

- 当两个指针指向的位置相同，快指针向前移动
- 当两个指针指向的位置不同，两个指针一起移动

返回的数字为慢指针的当前位置 + 1（因为初始化位置为 0）



### 三数之和

> 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。
>

#### 思路

最后的输出存在要保证三个性质：

- 加和为 0
- 输出顺序
- 三元组无重复

##### 加和为 0 且输出顺序

首先将输入数组排序，利用三个指针，分为 `left` `mid` `right` ，保证 left 永远指向最小的数，mid 为 left 的下一个数，right 为最右边的数。每次固定 `left` 则该问题变为 `2Sum` 问题。即 mid 与 right 之和为 0 - nums[left]

##### 三元组无重复

因为输入数组排序，每次 left 遇到重复的数字则直接进行跳过，mid 与 right 进行同样的操作



### 最接近的三数之和

> 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。
>
> 例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.
>
> 与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).
>

#### 思路

与三数之和的思路一致，只不过要找最接近的。定义一个当前最小，并且实时对当前答案进行更新即可



### 四数之和

> 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

#### 思路

利用三数之和的思想

- 第一次固定第一个值

  - 固定第二个值，注意，每次第一个值更新之后，第二个值的初始位置都要进行更新
    - 利用夹逼法则，利用两个指针进行扫描数组的前后




### 移除元素

> 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
>
> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
>
> 示例 1:
>
> 给定 nums = [3,2,2,3], val = 3,
>
> 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
>
> 你不需要考虑数组中超出新长度后面的元素。
>

#### 思路

使用两个指针，两个指针初始都指向数组的头，也就是 0 位置。

- cur_pos 指针用来代表当前位置的元素
- judge 指针的位置永远大于等于 cur_pos，用以判断下一个元素是否等于给定的 val 值

如果judge 位置的元素不等于给定的 val 值，则将judge 位置的元素赋值给 cur_pos 的指针的位置，且 judge +1 以及 cur_pos + 1

如果 judge 位置的元素等于给定的 val 值，则仅将 judge + 1



### 下一个排列

> 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
>
> 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
>
> 必须原地修改，只允许使用额外常数空间。
>
> 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
> 1,2,3 → 1,3,2
> 3,2,1 → 1,2,3
> 1,1,5 → 1,5,1

- 从后往前找到第一个逆序对
  - 第一个数和前面的所有数比对，如果没有，第二个数和前面所有的数进行比对
- 找到逆序对，交换位置，设为 i,j (i > j)
- 记住 i 的位置，将 i 之后的所有元素逆序



### 在排序数组中查找元素的第一个和最后一个位置

> 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
>
> 你的算法时间复杂度必须是 O(log n) 级别。
>
> 如果数组中不存在目标值，返回 [-1, -1]。
>
> 示例 1:
>
> 输入: nums = [5,7,7,8,8,10], target = 8
> 输出: [3,4]
> 示例 2:
>
> 输入: nums = [5,7,7,8,8,10], target = 6
> 输出: [-1,-1]

#### 解法：

利用二分法进行搜索，因为目标为整数数组，则利用二分法搜索 target - 0.5 以及 target + 0.5 的值

##### 注意：

需要注意二分法跳出的步骤，在搜索 - 0.5 以及 + 0.5 时，判断循环跳出的步骤为

```python
while left <= right:
	执行
return left
```

在上述情况下，

- 当搜索 -0.5 时，left 返回的是第一个数组中的值，如果不存在该值，则返回 -1
- 当搜索 + 0.5 时，left 返回的是最后一个该 target 的值，如果该值不存在，则有可能返回越界值，此时需要判断



### 35. 搜索插入位置

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
>
> 你可以假设数组中无重复元素。
>
> 示例 1:
>
> 输入: [1,3,5,6], 5
> 输出: 2
> 示例 2:
>
> 输入: [1,3,5,6], 2
> 输出: 1
> 示例 3:
>
> 输入: [1,3,5,6], 7
> 输出: 4
> 示例 4:
>
> 输入: [1,3,5,6], 0
> 输出: 0

#### 解法：

使用二分法进行搜索

- 如果当前值存在于数组中，则就是简单地二分法

- 如果当前值不存在与数组之中，

  - 如果 target 小于数组中的某一个元素（也就是target可以插入在数组中间），则返回的则是第一个大于该target的值

  - ```python
    while left <= right:
    	执行
    	if nums[mid] == target:
    		return mid
    rturn left
    ```

  - 如果 target 大于数组中的所有元素则返回的则是越界的数字位置，也就是 `len(nums)`



### 组合总和

> 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
>
> candidates 中的数字可以无限制重复被选取。

#### 解法：

递归进行求解：

- 有三个参数需要传入递归搜索当中
  - cur_ans, ans, target
  - 其中 cur_ans 代表当前解，ans 代表所有可能的解，target 代表当前解距离真实 target 还差多少



### 组合总和2

> 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
>
> candidates 中的每个数字在每个组合中只能使用一次。
>
> - 所有数字（包括目标数）都是正整数。
> - 解集不能包含重复的组合。 

与上述有所不同，因为数字中不保证无重复，所以可以存在重复元素如 $[10,1,2,7,6,1,5]$ 

对数组进行排序后，进行递归搜索，如何避免重复的组合

```python
for i in range(cur_pos,len(data)):
	if i != cur_pos and data[i-1] == data[i]:
		continue
```

以上述数组举例
$$
[1,1,2,5,6,7,10]
$$
第一个 1 存在一个解 $[1,2,5]$

当循环到第二个 1 时，因为其不是该循环的初始值，（初始值为第一个1），且与其前一个值相等，表示当前值与之前值会存在相同的解空间，所以直接跳过





### 旋转图像

> 给定一个 n × n 的二维矩阵表示一个图像。
>
> 将图像顺时针旋转 90 度。
>
> 说明：
>
> 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。
>
> 给定 matrix =
> [
>   [ 5, 1, 9,11],
>   [ 2, 4, 8,10],
>   [13, 3, 6, 7],
>   [15,14,12,16]
> ], 
>
> 原地旋转输入矩阵，使其变为:
> [
>   [15,13, 2, 5],
>   [14, 3, 4, 1],
>   [12, 6, 8, 9],
>   [16, 7,10,11]
> ]

#### 解法

难点在于确定交换数据的坐标值

- 使用两层循环，外圈每一次循环对矩阵的每一圈完成旋转的操作，到 $\frac{n}{2}$ 为止
- 内圈到 $len(data) - 1 - i$ 为止

以上述 4 x 4 矩阵举例，这是内圈的操作，内圈的一次循环对 4 个位置进行相似的循环，(0,0),(0,1),(0,2),(0,3) 即完成最外圈的旋转操作

-  $(0,0) \rightarrow (0,3)$
- $ (0,3) \rightarrow (3,3)$
- $ (3,3) \rightarrow (3,0)$
- $ (3,0) \rightarrow (0,0)$



###  最大子序和

> 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
> 示例:
>
> 输入: [-2,1,-3,4,-1,2,1,-5,4],
> 输出: 6
> 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6

两个需要注意的点：

- 如何定义系统最小值

  - ```python
    fin_min = float('-inf')
    import sys
    fin_min = -sys.maxsize()-1
    ```

- 如何在负数情况下，进行最大子序和

  - 在全为正数的数组中，可以使用

    - ```python
      if tem_sum <0:
      	tem_sum = 0
      ```

  - 在包含负数的数组中，

    - ```python
      tem_sum += cur_data
      tem_sum = max(tem_sum,cur_data)
      ```

      

#### 分治法

停止条件：

- 当子数组中只剩一个数字的时候，则返回该数字，即 `left = right`

分支法求取子数组的最大值分为三个部分，以中间值为划分：

- 左半边的最大值
- 右半边的最大值
- 从中间向左右两边延伸的最大值

以 $[-2,1,-3,4]$ 举例，中间值为 1，左半边为 $[-2,1]$, 右半边为$[-3,4]$

- 跨越边界的值为，
- 从 1 向左延伸，包含每一个向左的数字（不能断开）的最大值
- 从 -3 开始，向右延伸，包含每一个向右的数组，不得断开，的最大值
- 两者相加即为跨越边界的最大值





### 顺时针打印矩阵（螺旋矩阵）

> 给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。
>
> 示例 1:
>
> 输入:
> [
>  [ 1, 2, 3 ],
>  [ 4, 5, 6 ],
>  [ 7, 8, 9 ]
> ]
> 输出: [1,2,3,6,9,8,7,4,5]
> 示例 2:
>
> 输入:
> [
>   [1, 2, 3, 4],
>   [5, 6, 7, 8],
>   [9,10,11,12]
> ]
> 输出: [1,2,3,4,8,12,11,10,9,5,6,7]

#### 解法

按照顺时针方向打印矩阵，每次打印的起始点在矩阵的对角线上 ： $(0,0),(1,1),(2,2),\ldots $

- 打印停止的条件：`start *2 < column and start * 2 < rows`

打印分为4步走：

- 打印第一行，只要打印不停止，总是需要打印第一行
- 打印最后一列（打印到最后可能就剩下一列，这时候打印第一行就是打印第一个数，然后向下打印）
  - 有限制条件，需要`end_row > start`, 也就是当前的行数要大于 start
- 打印最后一行，存在限制条件，需要当前至少为 2 行 2 列
  - `end_row > start and end_col > start`
- 打印第一列，存在限制条件，需要至少为 3 行 2 列
  - `end_row - 1 > start and end_col > start`





### 跳跃游戏

> 给定一个非负整数数组，你最初位于数组的第一个位置。
>
> 数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
> 判断你是否能够到达最后一个位置。
>
> 示例 1:
>
> 输入: [2,3,1,1,4]
> 输出: true
> 解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
> 示例 2:
>
> 输入: [3,2,1,0,4]
> 输出: false
> 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。

#### 解法：

##### 贪心算法：

每次保留当前位置所能到达的最远距离，如果其大于最终的数组长度，表示可到达数组尾端，否则则不能

##### 动态规划：

利用动态规划数组节省时间，数组保存到达当前位置时，还剩下的最大跳力，递推公式如下
$$
dp[i] = max(dp[i-1],nums[i-1]) - 1
$$



### 56. 合并区间

> 给出一个区间的集合，请合并所有重叠的区间。
>
> 示例 1:
>
> 输入: [[1,3],[2,6],[8,10],[15,18]]
> 输出: [[1,6],[8,10],[15,18]]
> 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
> 示例 2:
>
> 输入: [[1,4],[4,5]]
> 输出: [[1,5]]
> 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。

#### 解法：

- 将列表进行排序
  - 列表排序时，会先按照第一个数字进行排序，如果第一个数字相同再按照第二个数字的大小进行排序
- 从第一个区间开始遍历
  - 存在三种情况，下一个区间完全与第一个不重叠，此时判断下一个区间的开始数字以及第一个区间的结束数字即可确定
  - 下一个区间与第一个区间部分重叠
  - 下一个区间与第一个区间完全重叠
    - 后两种情况可以使用同一种方法进行判别
    - 保留原始区间的起始值，终点值在原来的终点值，以及下一个区间的终点值之间取 max



### 57. 插入区间

> 给出一个*无重叠的 ，*按照区间起始端点排序的区间列表。
>
> 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。
>
> 示例 1:
>
> 输入: intervals = [[1,3],[6,9]], newInterval = [2,5]
> 输出: [[1,5],[6,9]]
> 示例 2:
>
> 输入: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
> 输出: [[1,2],[3,10],[12,16]]
> 解释: 这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。

#### 解法

对区间进行合并，分为三步

- 寻找第一个与新区间存在交集的区间，

  - ```python
    while cur < length and intervals[cur][1] < newInternvals[0]:
        do something
        cur += 1
    ```

  - 当循环跳出时，cur 即为第一个有重叠的区间

- 找到 cur 的位置，寻找所有与新区间存在交集的区间，需要进行合并

  - ```python
    while cur < length and intervals[cur][0] < newIntervals[1]:
    	newIntervls[0] = min(internvas[cur][0],newIntervals[0])
        newIntervls[1] = max(internvas[cur][1],newIntervals[1])
    ans.append(newIntervals)
    ```

- 添加所有剩余区间




## 图相关



### 克隆图

给定一个图，需要对其每个节点，每条边进行克隆，分为深度优先和广度优先两种方法

建立 `Visit` 字典，其中 `键` 为原始图的节点，`值` 为相对应的克隆图的节点，对**原图的节点**进行遍历

- 如果原图的邻节点不在 `Visit` 字典中，说明该节点之前没有遇到过，需要进行克隆
  - 根据邻节点的值，创建一个新的节点 `Node(neighbor.val,[])`
  - 将该节点作为 `值` 添加到以邻节点作为`键` 的 `Visit` 字典中（也就是在 `Visit ` 中添加新的键值对）
  - 将**克隆节点的当前节点**的 [neighbors] 中添加该克隆节点
- 如果原图的邻节点在 `Visit` 字典中，说明该节点之前遍历过