---
layout:     post   				    # 使用的布局（不需要改）
title:      剑指Offer(长期) 				# 标题 
subtitle:   data structure          #副标题
date:       2019-07-05 				# 时间
author:     WYX 						# 作者
header-img: img/5.1.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - data structure  

---



# 剑指 offer 笔记

本文长期记录剑指 Offer 刷题中需要注意的点

---

### 二维数组中的查找

> 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数

#### **自己的想法**

用二分法搜索每一行。如果一行的第一个值大于想要的数字，则退出。先判定数组是否为空，为空的话返回 False

**注意**：系统输入的是一个二维的空列表，判定大小要注意

```
array = [[]]
# 使用 len 判定数组是否为空有问题,len(array) 输入为1
```

#### 讨论中的想法：

从左下开始搜索，如果当前数据大于 want_num 则向上移动一位；如果当前数据小于 want_num 则向右移动一位；梯度上升



### 替换空格

> 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

#### 自己的想法

使用python 内置函数 replace 直接进行替换

```python
a = 'asd2 qweasda'
a = a.replace(' ','%20')
```

#### 讨论（可以查看在线解析）

- 首先扫描字符串中一共有多少个空格
- 在字符串后面添加 2 * num_space 的任意字符
- 使用两个变量分别记录真正的字符串的最后一位以及添加字符串的最后一位
- 两个变量同时向前移动
  - 如果真正的字符串当前指的不是空格，则将当前指的值赋值给添加字符串当前的位置
  - 如果真正的字符串当前指的是空格，则将添加字符串位置向前移动三位，并在移动过程中添加 “%20”

![替换空格](https://ae01.alicdn.com/kf/HTB1F9JtXxv1gK0jSZFF7620sXXaa.png)

在增加字符串长度的过程中，首先将字符串转为了 list，然后在list后面添加

```python
string = list(s)		
string2 = ['0' for i in range(num_space*2)]
string += string2
```



### 从尾到头打印列表

> 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。

#### 自己的想法

- 将链表每一个值从头到尾储存在一个列表中
- 将列表翻转. 
  - list.reverse()
- 打印列表

#### 讨论

进行递归调用

终止条件为：

- 当列表当前值为 None 时，表示当前访问 Node 为最后一个值的下一个值。则返回空列表 []

```python
 if listNode is None:
        	return []
        else:
        	return self.printListFromTailToHead(listNode.next) + [listNode.val]
```



### 重建二叉树

> 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

#### 自己的想法

递归求解

以下图的二叉树为例

 <center>
    <img src="https://github.com/joseph-mutu/Pics/raw/master/reconstruct binary trees(jianzhi).jpg" width="200"/>
</center>

根据前序以及中序遍历的结果，可以恢复二叉树。

- 前序遍历的结果中，首位的数是**当前**二叉树的**根节点**
- 根据当前二叉树的根节点，在中序遍历结果中，根据当前子树的length，查找其左右子树
  - 如，初始情况下，当前二叉树的根节点为 1
  - 在 in 列表中定位 1，当前二叉树的 length 为 6。1 在 in 列表中的位置为 3（从 0 开始）。则其左子树长度为 3（左子树中存在 3 个元素）。右子树的长度的 “当前二叉树长度 - 左子树长度 - 1 ”
- 递归求解左子树以及右子树。将左子树视为当前二叉树。移动 pre 列表中的首位元素（根据左子树长度以及右子树长度进行分别移动到左右子树的根节点）。
- 对于当前左子树来说，根节点为  2。对于当前右子树来说，根节点为 5
  - 求解左子树
    - 左子树长度为 3。则当前二叉树长度为 3。在 in 数组中定位到其根节点 2，索引为 1。则左子树的左子树长度为 1 - 0 = 1。左子树的右子树长度为 3 - 1 -1 = 1。
  - 求解右子树
    - 右子树长度为 2。则当前二叉树长度为 2。在 in 数组中定位其根节点 5，索引为 5。则右子树的左子树长度为 5 - 4 = 1。右子树的右子树长度为 2 - 1 - 1=0
      - 注意对于右子树来说，in 数组的起始索引为 4。

##### 递归终止条件

由上述描述可知，两种情况

- 子树长度为 1。则当前传入节点为叶节点。即 cur_node.left = None. cur_node.right = None
- 子树长度为 0。当前传入节点无叶节点。直接返回



### 用两个栈模拟队列

> 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

#### 想法



<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E4%B8%A4%E4%B8%AA%E6%A0%88%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97.png" width ="400"/>
</center>





分为 Push 操作和 pop 操作，模拟的是队列的先进先出原则

- Push 操作将每一个元素按照栈的操作先压到第一个栈中。如上图第一个栈的 A,B,C,D
- Pop 操作首先判断第二个栈是否为空
  - 如果为空，将第一个栈的所有元素按照 pop 的顺序压到第二个栈中。此时顺序调换
    - 如D,C,B,A 此时被压到第二个栈中
    - Pop 第二个栈的元素。模拟先进先出
  - 如果不为空，则 return 第二个栈的pop元素





### 旋转数组里的最小数字

> 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
> NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

##### 题目理解

原数组为一个**非递减**数组。但是输入数组为经过旋转之后的数组。此题只考虑旋转一次或者没有旋转的情况。

- 非递减意味着，数组中可能存在重复的元素。即[1,1,0,1,1] 这样的数组也存在于输入中





<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.jpg" width = "300"/>
</center>



- 原数组在进行旋转之后，输入数组可以分为两部分。**且两部分顺序皆为非递减排序**。**且第一部分元素皆大于等于第二部分元素**。即上述白色以及灰色部分
  - 旋转数组的最小值在旋转数组两部分的分界处。即要找到原数组的第一个值



##### 题目解法

使用二分法。但是每次要保证两个指针不会彼此错位。即第一个指针要始终在第一部分移动(白色)，第二个指针始终在第二部分移动（灰色）。

###### 如何保证指针彼此不错位

P1 初始位置指向输入数组的第一个值。P2 初始位置在输入数组的最后一个值。

- 首先选取中间值。 mid = (int) (P1 + P2)/2
- 中间值有两个可能。在白色区域，或者在灰色区域。
  - 在白色区域，则中间值比 P1 此刻的值大（相等）。
    - 将 P1 指向中间值所在的位置
  - 在灰色区域，则中间值比 P2 此刻的值小（相等）。
    - 将 P2 指向中间值所在的位置



但是上述解法没有考虑到特殊情况。（原数组为**非递减数组**）



###### 题目特例

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%EF%BC%88%E7%89%B9%E4%BE%8B%EF%BC%89.jpg" width = "600"/>
</center>

- 如果中间值与 P1 和 P2 值完全相等。则无法判断中间值处于哪一个区域。则只能用顺序查找进行
- 第二种特例。如果在开始的时候，P1 的值就小于 P2 的值。则数组没有旋转。直接输出 P1



### 青蛙跳台阶以及变态跳台阶

#### 青蛙跳台阶

> 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

##### 题目理解

斐波那契数列的应用。从只有一级台阶分析

- 1 级台阶。只有一种跳法。f(1) = 1
- 2 级台阶。有 2 种跳法。1 + 1/2。f(2) = 2
- 3 级台阶。可以从  1 级台阶跳到 3 级 / 从 2 级台阶跳到 3 级。所以 f(3) = f(1) + f(2)
  - 注意从 1 级到 3 级只有一种跳法 1 + 2。从 1 级先到 2 级再到 3 级这种情况已经被 f(2) 囊括在内（1+1+1）





#### 变态跳台阶

> 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

题目理解

从只有一级台阶分析

- 1级台阶。一种跳法
- 2 级台阶。2 种跳法。从 0 到 2/ 从  1到 2
- 3 级台阶。0 -> 3 / 1->3 / 2->3 = f(0) + f(1) + f(2)。因为无论几级台阶都能直接跳。则设定  f(0) =  1
- 4 级台阶。f(0) + f(1) + f(2) + f(3)
- ...

假设求 f(4) = f(0) + f(1) + f(2) + f(3)，有

- 因为 f(3) = f(0) + f(1) + f(2)
- 则 f(4) = 2*f(3)

以此类推

- f(n) = 2*f(n-1)



### 矩形覆盖

> 我们可以用2 * 1的小矩形横着或者竖着去覆盖更大的矩形。请问用 n个 2 * 1的小矩形无重叠地覆盖一个2 * n的大矩形，总共有多少种方法？

#### 题目理解

从只有一个矩形来看。

- 当矩形只有一个时，显然，只有一种方法覆盖
- 当矩形存在两个时。存在两种方法。一种竖着一种横着。**注意**，矩形的顺序无影响。

<center>
    <img src ="https://github.com/joseph-mutu/Pics/raw/master/%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%961.png" width = "500"/>
</center>

- 当矩形的存在为 3 个时，如下图所示。因为增加了一个小矩形，就增添了一种横着放的可能（下图，从 f(1) 到 f(3)）。

  <center>
      <img src= "https://github.com/joseph-mutu/Pics/raw/master/%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%962.png" width = "500"/>
  </center>

  

由以上可以得出，矩形覆盖 f (n) 依赖于其前两个状态 f(n-1) f(n-2)



### 二进制中 1 的个数

> 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

#### 题目理解

##### 原码，反码以及补码表示

8 的二进制**原码**表示为：


$$
1000: 0 \times 2^0 + 0 \times 2^1 + 0 \times 2^2 + 1 \times 2^3
$$


所谓反码即为将原码中 **1** 与 **0** 互换，如上述 8 的反码为：


$$
1000 \Rightarrow_{反码} 0111
$$


在 32进制中，数字使用补码来表示负数。所谓补码，即反码 + 1。且最高位为符号位（0 表示正数，1 表示负数。符号位在变为反码的过程中不变化）。下述为 -1 的反码表示。


$$
原码:~ 1(符号位)000 ~ 0000 ~ 0000 ~ 0000 ~ 0000 ~ 0000 ~ 0000 ~ 0001
$$

$$
反码：~1(符号位)111 ~1111 ~1111 ~1111 ~1111 ~1111 ~1111 ~1110
$$

$$
补码（反码 + 1）~ : ~1(符号位)\underbrace{111 ~1111 ~1111 ~1111 ~1111 ~1111 ~1111 ~1111}_{序号位}
$$

##### 一般情况下如何求 1 的个数（针对正数）

以 12 举例，在 32 位的情况下，12 的二进制原码表示如下：


$$
0000 ~ 0000 ~ 0000 ~ 0000 ~ 0000 ~ 0000 ~ 1100
$$


现在将 12 减去 1，为 11 ，观察 11 的二进制码


$$
1100 \Rightarrow 1011 : 1 \times 2^0 + 1 \times 2^1 + 0 \times 2^2 + 1 \times 2^3 = 11
$$
观察得到，将一个数，减去1之后所得到的二进制码**只改变原数**二进制原码，**最右边**的1，并将最右边的1之后的 0 取反。

则，若将 12-1 与 12 再次进行位与运算，如下


$$
\begin{equation}
位与 \left\{
\begin{aligned}
& 1001 \\
& 1100 \\
\end{aligned}
\right.
\end{equation}

\Rightarrow 1000
$$


则次操作可以视为，消去最右边一个 1。重复此操作，直至最后结果为 0 为止。



**Note:**

在 python 中，负数 不可使用上述的方法，会陷入循环。因为python 中不使用补码的形式表示负数。

##### 解决方法

```python
n = n if n > 0 else n & 0xFFFFFFFF
```

将 -1 & 0xFFFFFFFF, 可以将 -1 的补码形式转换成一个无符号数，也就是其补码形式相对应的正数。从而再进行操作。



### 数值的整数次方

> 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。

#### 题目理解

1. 拿到题目首先要确定题目的特例
   1. 任何数的 0 次幂为 1
   2. 0 的任除1外的任何次幂皆为 0 
   3. 负数次幂为其正数次幂的倒数
      1. 注意特例， 0/任何数 无意义



#### 题目解法

使用快速幂，而不是如下所示每次叠加一次

##### 低效率

```python
for i in range(numExponent):
    base *=base
return base
```



##### 快速幂分析

任何整数均可以表示为二进制形式，如 12 的二进制形式如下：


$$
1100 : ~ 0 \times 2^0  + 0 \times 2^0 + 1\times 2^2 + 1 \times 2^3
$$


则如果要求 $2^{12}$ , 则可以将其分解为如下形式：


$$
2^{12} = 2^{0 \times 2^0  + 0 \times 2^0 + 1\times 2^2 + 1 \times 2^3} \\
\space  \\
=2^{0 \times 2^0} * 2^{0 \times 2^0} *2^{1\times 2^2 } *2^{1 \times 2^3}
$$


note：在上述形式中，只有当当前的二进制码为 1 的时候，才进行相乘。则算法的想法为：

- 从右边的第一个二进制码开始，如果当前的二进制码为  1 ，则与当前的 curBase 相乘
- 如果当前的二进制码为 0，则只累计 curBase
- 将当前的 exponent 移位
  - 以 12 举例。其当前的二进制表示为 1100。
  - 此时判断其二进制表示的最后一位是否为 1
  - 将 12 向右移动一位
    - 0110： $2^0 \times 0 + 2^1 \times 1 + 2^2 \times 2 = 6$
  - 循环判断，当 exponent 移位至 0 时，结束判断

```python
while exponent:
    if exponent & 1:
        ans *= curBase
        curBase *= curBase
    exponent >>= 1
```

##### 技巧

- 使用左移右移代替乘法除法

  - 左移为乘法

  - 右移为除法

    - ```python
      3<<1
      输出为：1，相当于 int(3/2)
      ```





### 调整数组的顺序，使奇数位于偶数前面

> 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

#### 题目解法

以如下数组举例


$$
[2,3,4,0,5,6]
$$

- 从头开始判断。以 temCount 记录操作的次数。当操作的次数与原数组长度相同时，结束

- 如果当前的位置元素为偶数，则将当前元素添加到数组的尾端，并从原数组中删除该元素

  
  $$
  [3,4,0,5,6,2]
  $$

- 当前位置元素为奇数时，操作数Count + 1，并 `Continue`



### 链表中倒数第K个节点

> 输入一个链表，输出该链表中倒数第k个结点。

#### 自己的想法

- 遍历链表，同时开辟一个列表存储所有的值
- 返回倒数第K个值

#### 无需开辟新数组的想法

利用两个指针，一前一后行成一个**“尺子”**, 当尺子的前端（离起点较远的那一端）到达链表的末尾时，此时尺子头所在的位置即为倒数第  K 个数字。如下图所示

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9.png" width = "800"/>
</center>

- 首先初始化两个指针为链表头。
- 将其中一个指针向前移动 K - 1 个位置。这样保证当尺子前端到达链表末尾的时候，尺子后端为倒数第K个数。
  - 这里需要注意判断边界条件，在移动尺子一端的时候，可能会出现两种情况
    - 尺子移动 K - 1 个位置刚好到达链表的末尾。也就是 `尺子前端.next = None`
    - 尺子移动 K - 1 个位置的过程中，超出了链表。此时输入不合法，返回 None
- 尺子定义完成后，只需要同时向前移动尺子的**“前端”**和**"后端"**，当前端达到末尾，返回后端



### 反转链表

> 输入一个链表，反转链表后，输出新链表的表头。

反转链表时需要三个变量。输入链表为单向的，如果直接反转的话，会失去原本的 next 值。

- 创建一个 next 值，在反转当前值之前记录其 next 的位置。
- 创建 last 值，记录当前值的前一个节点的位置。
- 不断移动当前值

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.png" width = "800"/>
</center>

最后需要返回的是 **last** 值。因为在处理最后一个节点时，pHead 成为 None

```python
pLast = None
while pHead:
    pNext = pHead.next
    pHead.next = pLast
    pLast = pHead
    pHead = pNext
return pLast
```



###  合并两个排序的链表

> 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

#### 总结

题目本身不难。需要注意的有以下几点

- **注意判断特殊情况**
  - 一个链表为空的情况。或者两个链表为空的情况
  - 注意思考递归的方式



### 树的子结构

> 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

#### 题目解法

递归搜索。输入两棵树，要判断 B 是不是 A 的子树分为两步：

- 在 A 中寻找到与 B 根节点相同的节点
- 根据搜索到的根节点，递归匹配其左子树与右子树，看是否相等。

<center>
    <img src=  "https://github.com/joseph-mutu/Pics/raw/master/Is%20B%20the%20subtree%20of%20A.png" width = "800"/>
</center>

在判断左子树与右子树是否相同时，有两个终止条件。

```python
def checkEquality(self,pRoot1,pRoot2):
    if pRoot2 is None:
    	return True
    if pRoot1 is None:
    	return False
    if pRoot1.val != pRoot2.val:
    	return False
    return (self.checkEquality(pRoot1.left,pRoot2.left) and self.checkEquality(pRoot1.right,pRoot2.right) ) or  (self.checkEquality(pRoot1.left,pRoot2.right) and self.checkEquality(pRoot1.right,pRoot2.left))
```

- 首先判断 B 树是否到达叶节点再判断 A 树是否到达叶节点。原因如下
  - 假设当前正处于 A 树的节点 9 以及 B 树的节点 9。则两节点相同，继续进行搜索。此时搜索为 `checkEquality(A9.left,B9.left) and checkEquality(A9.right, B9.right)` ,因为以是否到达叶节点为判断依据。如果调换判断的顺序，先判断 `if pRootq is None` 则直接返回 False。
- 停止依据，如果B树到达叶节点，则为True。如果A树到达叶节点则为 False
- 上述两个判断**不可以**改成下述判断

```python
def checkEquality(self,pRoot1,pRoot2):
    if pRoot2 is None and pRoot1 is None:
    	return True
    if pRoot1 is None or pRoot2 is not None:
    	return False
   	if pRoot1 is not None or pRoot2 is None:
        return False
```

原因在于，A 树大于 B 树。考虑当前搜索节点为 A7 和 B7。B树搜索完成，节点全部匹配。现在搜索 `checkEquality(A7.left,B7.left) and checkEquality(A7.right,B7.right)`，则返回 False



### 二叉树的镜像

> 操作给定的二叉树，将其变换为源二叉树的镜像。

#### 题目理解

将二叉树所有的左右儿子进行调换

#### 题目解法

递归求解。

- 当到达二叉树叶节点的时候，返回 None
- 当二叉树为单边数树时，进行`root.right = root.left` 之后，要对 `root.left`赋值为 None

```python
if root.left and root.right:
    tem = root.right
    root.right = root.left
    root.left = tem
    root.left = self.	Mirror(root.left)
    root.right = self.Mirror(root.right)
elif root.left:
    root.right = root.left
    root.left = None
    root.right = self.Mirror(root.right)
elif root.right:
    root.left = root.right
    root.right = None
    root.left = self.Mirror(root.left)
```



### 顺时针打印矩阵

> 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.

#### 题目理解

题目的难点在于如何分析题目。

顺时针打印一共可以分为 4 个步骤：

- 横向打印
- 打印最后一列
- 打印最后一行 （从右二到左） 
- 打印第一行（从底二到上）

打印的操作可以取决于 **4** 个变量：

- 起始行数，起始列数。这两个参数，每次增加1。比如第一次打印时，起始行数起始列数为 （0,0）。第二次打印时，起始行数，起始列数为（1,1）

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B51.png" width = "600"/>
</center>



- 当前的总行数，当前的列的长度。
- 每次结束一圈打印之后，当前的行数以及列数就会 **- 1**。同时起始行数起始列数 **+ 1**

<center>
    <img src= "https://github.com/joseph-mutu/Pics/raw/master/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B52.png" width = "600"/>
</center>

##### 4 种打印所需要的条件

4 中操作有先后顺序。只要前一圈打印结束之后还存有元素没有被打印，第一种操作总会进行

- 第一种操作：只要起始行数，起始列数大于等于**当前行数长度**以及**当前列数长度**
- 第二种操作：在满足第一种操作的情况下，当前**行数至少为 2** 才需要进行第二种操作
- 第三种操作：行数至少为 2 且列数至少为 2。
- 第四种操作：行数至少为 3，列数至少为 2。

当第一种操作的条件不满足时，退出循环。矩阵完成打印

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B54.png" width = "600"/>
</center>



### 包含 min 函数的栈

> 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。

#### 题目理解

要用时间复杂度为 O(1) 得到当前的最小元素。

- 利用另一个堆栈，存储最小元素，第二小元素，第三小...
- 每压入一个元素，进行一次对比，如果比当前的最小值小，则将当前元素压入**原始栈**的同时，压入**最小元素栈**
  - 比如依次压入 “3,4,2,5”。则最小元素栈中存储 ”3,2“ 
- 进行元素 pop 的时候，进行对比。如果当前 pop 元素等于最小元素栈中栈顶元素，则同时将最小元素从最小元素栈删除



### 栈的压入弹出序列

> 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

#### 题目理解

- 建立一个辅助栈，根据题目提供的压入顺序对相应元素进行堆栈。
- 堆栈的同时，对弹出序列进行检测。如果当前入栈的元素与出栈序列相同，则 辅助栈.pop()。同时删去弹出序列中的相同元素。
- 当堆栈结束，但是弹出序列中仍有元素时，表示弹出序列不可能。



###  从上到下打印二叉树

> 从上往下打印出二叉树的每个节点，同层节点从左至右打印。

#### 题目理解

二叉树的遍历。同层节点从左到右打印，依赖队列，先将 root 节点压入队列，然后判断其是否有左右儿子，如果有继续压入队列，然后弹出 root 节点。依次循环，直至队列为空



### 二叉树的后序遍历列表

> 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。

#### 题目理解

首先二叉搜索树意思是：

- 根节点的左子树一定比根节点的值小
- 根节点的右子树一定比根节点的值大

后序遍历的特点在于：

- 遍历结果的最后一个元素一定为当前二叉搜索树的根节点。
- 后序遍历从根节点的左子树开始


$$
\lbrace 1,2,5,8,6,3 \rbrace
$$
则 3 一定为当前搜索树的根节点。

- 根据后序遍历的特点，当前搜索树的左子树为后序遍历序列中，从 0 位置开始比根节点小的值。右子树为剩余的值。以上述二叉树举例

$$
左子树: \lbrace 1,2  \rbrace \\
\space \\
右子树: \lbrace 5,8,6 \rbrace \\
$$

且左子树一定是从 0 位置开始，连续的比根节点大的值。右子树同样一定是连续的位置的值

#### 题目解法

- 提取二叉搜索树的根节点
- 按照根节点，提取其左子树的值（从 位置 [0] 开始比较，一直比较到大于根节点的位置为止）
- 此时剩余的值为右子树的值
- 扫描右子树的值，如果**出现比根节点小的值**则该序列不可能



### 二叉树中和为某一路径的值

> 输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)

#### 题目理解

重点在于递归向下，返回的时候要回退到当时的状态。

- 比如递归到左子树的叶节点 1 时，发现路径符合，则将当前路径添加进最终的路径，并返回上一层节点
  - 递归调用的时候，传入的路径是一片相同的地址，所以，在不断递归向下的时候，当前的路径也在不断添加新的节点。在回传的时候，要注意删除当前的节点。

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/path%20Sum%20in%20binary%20search%20tree.png" width = "750"/>
</center>



### 复杂链表的赋值

> 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）

#### 题目理解

相较于传统列表，复杂链表多了一个指向任意节点的指针

#### 题目解法

##### 使用字典

- 按照原链表的顺序以及相应的值，每次新建一个节点并赋相同的值，进行连接
  - 同时，将原链表相对应的节点，和新建的节点，进行一一配对，存储进一个字典
- 从头扫描新链表以及原链表，如果原链表中相应节点存在 pHead.random 的话，将其读入字典，找到在新链表中对应的节点，进行连接

```python
if pHead.random:
	newHeade.random = self.totalDic[pHead.random]
```

##### 不使用字典

- 按照原链表的顺序，在原链表上对其进行复制，如下

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A81.jpg" width = "500"/>
</center>

- 从新扫描该链表，如果原链表的节点存在 random，则进行连接

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A82.jpg" width = "500"/>
</center>

```python
# pHead 只指向原链表的节点。A，B，C，D，E
newHead = pHead
if pHead.random:
	newHead.random = pHead.random.next
```



- 将两个链表分离

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A83.jpg" width = "500"/>
</center>

### 二叉搜索树与双向链表

> 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

#### 题目理解

首先明确，二叉搜索树的左子树的所有节点**小于**根节点，右子树的所有节点**大于**根节点。最终返回头结点

- 当只存在一棵树（一个根节点，以及一个左叶节点，一个右叶节点）
  - 排列顺序为 左叶 --> 根节点 --> 右叶节点
- 递归求解的过程中，
  - 对于左子树，要将**左子树中的最大值**与根节点相连接
    - 由于题目返回头结点，在递归求解过程中，头结点为当前序列的最小值。连接左子树时，每次要寻找到排好序的序列的最右节点并返回。
  - 对于右子树，要将**右子树中的最小值**与根节点相连接
    - 头结点为当前序列的最小值，所以右子树只需要返回头结点即可

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%92%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" width = "900"/>
</center>



### 字符串中的所有排列

> 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。
>
> ```
> 输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。
> ```

#### 题目理解

以字符串 “abc”举例，
$$
"a": 0 \space \\
"b":1 \space \\
"c":2
$$
是一个递归的过程，首先字符串的 start 和 end 均在首位。这里需要注意一点。以下代码是不进入 print 函数的，会直接返回

```python
for i in range(0,0):
	print(i)
```

- 首先初始状态为 abc, 将字符串 0 与 0 的位置进行交换。
  -  递归进入下一个状态 bc, 将此时字符串的 1 与 1 的位置进行交换
    - 同时递归再进入下一个状态 c，此时到达字符串的末端，将当前字符串添加进可能的序列 **"abc"**，返回上一状态
  - 因为从下一状态返回当前状态时，要将已经交换的字符串恢复原位，所以再将 1 与 2 的位置进行交换
  - 将字符串 0 与 1 的位置进行交换，此时字符串为 cb, 递归进入下一状态
    - 此时状态为 b，到达末端，添加 **“acb”** ，返回上一状态
  - 将已经交换的字符串恢复，交换 cb，当前字符串为 **abc** 。因为上一步将 1 与 2 的位置交换。则到达当前状态末端，返回上一字符串
- 将字符串归为，将  0 与 0 再次交换
- 进行 0 与 1 的交换，当前字符串为 bac
  - 递归进入下一状态 ac

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97.png" width = "800"/>
</center>



#### 题目难点

遇到字符串中存在重复的字符时，以 “abb”举例

- 对于位置 0 **（a）** ，该位置递归有 3 个可能
  - 位置 0 与 位置 0 
  - 位置 0 与 位置 1
  - 位置 0 与 位置 2
- 发现，位置 0 与 位置1交换后 为 "bab"
  - 位置 0 与 位置 2 交换后仍为 “bab”
  - 且随后的递归状态相同
    - a 与 a 交换
    - a 与 b 交换 ，到达尾部，添加 **“bab”**

则，**如果当前其实位置，与当前递归位置之间，存在重复的元素，则跳过，递归位置 + 1**



### 数组中出现超过一半的数字

> 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。

#### 题目解法

数组中某一数字出现超过一半，意即**该数字出现的次数，超过其他所有数字出现次数之和**，

- 从数组头开始扫描，遇到第一个数字，将其记住，并将其出现的次数记为1
- 遇到第二个数字，若与第一个数字不同，则次数 -1 。
- 当出现次数为 0 时，初始化。重新记住下一个出现的数字，并将其出现的次数记为1 
- 将得到的数字，进行检查，是否出现次数超过一半
  - 如果为否，则说明数组中没有这种数字



### 最小的 K 个数

> 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。

Partition 函数参考: [浙江大学MOOC 数据结构](http://www.icourse163.org/learn/ZJU-93001?tid=1003997005#/learn/content?type=detail&id=1007588514&cid=1009165154)

---

#### 题目解法

题目用到了在快速排序中使用的 Partition 函数

- 每次选定一个数作为 **Pivot**，将数组分为左右部分
- 左边部分全为小于等于 **Pivot** 的值，右边部分全为大于 **Pivot** 的值
- 如果当当前的 **Pivot** 的数组位置为 **K- 1** 时，则数组左边即为所求的最小的 **k** 个数



<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/Partition%20%E5%87%BD%E6%95%B0.png" width = "1200"/>
</center>

Note:

- 指针移动时，先移动左指针再移动右指针
  - 当左指针遍历完成后，它指向大于 Pivot 部分的值，然后停住
  - 此时右指针开始移动，并指向左指针的最后一个元素（小于 Pivot 部分的值），停住
    - 注意要进行判断交换，因为**左右指针均停住**是**之前进行元素交换**的条件
    - 但是此时左右指针的元素不进行交换
  - 此时，左指针的位置，既是与 Pivot 元素交换的值

```python
while data[leftPointer] < data[Pivot]:
	leftPointer += 1
while data[rightPointer] > data[Pivot]:
    rightPointer += 1
if leftPointer < rightPointer:
    Swap(leftPointer,rightPointer)
```



### 连续子数组的最大和

> HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)

#### 题目解法

求得连续子数组的最大和。

- 从数组头开始扫描，遇到一个数加一个数（无论正负），将值付给 temSum，并随时更新 maxSum 的值，当temSum > maxSum 时更新
- 当temSum 为负时表示**之前的序列**不会给**之后的序列**带来**值上的增益**，将 temSum 重置为 0，重新进行记录



### 整数中 1 出现的次数

> 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。

#### 自己的想法

将每一个数化为 `string`， 然后对 string 中每一个位置进行对比，如果是 1 的话，就将 count_1 + 1。时间复杂度为 $O(nlogn)$

#### 题目解法

参考：[[从1到n整数中1出现的次数](https://www.cnblogs.com/xuanxufeng/p/6854105.html)]

---

以数字 `31526` 举例。每次统计每一个 `位` 上 1 在当前数字下，出现多少次。意即，个位上到 31526 一共能出现多少次 1，十位上 到 31526 一共能出现多少次 1 

- 首先按照位数将数字拆分。如果当前查找状态为 十位数，则将 31526，拆分成 $3152|6$ 两个部分。
- 将 3152 + 8。根据如下讨论，十位数出现 1 的次数将取决于原数字的十位数（也就是3152 末尾的2）是否大于 1，还是等于1 还是等于 0。大于1 与 等于 0 两种情况可以合并计算
  - 若原数字十位数 等于 0，假设为 3150，则加上 8 ，在进行 /10 操作，仍为 315。则表示在十位上出现 1 的次数为 315 + 1
  - 若原数字十位数大于 1，加上 8 则刚好进位。说明在十位上出现 1 的次数为 316 + 1
- 若十位的数字为 1 
  - 则十位上出现1的次数 要再加上 10,11,12,13，14,15,16 ，7 次

#### “位数”解释

##### 个位

###### **当原数中的个位大于 1 时**

`31526` **中个位为 6**
$$
0|1 \rightarrow 1|1 \rightarrow 21 \rightarrow 3|1 \ldots 3151|1 \rightarrow 3152|1
$$
每隔 10 个数出现 1 次

则 31526 中一共出现 3152 次个位数中的 1，再加上 个位上的 6 因为 大于 1 则 一共有 3152 + 1 次

###### 当原数中的个位等于 1 时

假设当前的原数为 `31521` 


$$
0|1 \rightarrow 1|1 \rightarrow 21 \rightarrow 3|1 \ldots 3151|1 \rightarrow 3152|1
$$


###### 当原数中的个位等于 0 时

假设当前的原数为 `31520` 


$$
0|1 \rightarrow 1|1 \rightarrow 21 \rightarrow 3|1 \ldots 3151|1
$$

##### 十位

###### 当原数中的十位大于 1 时

原数为 `31526` ，其十位数为 2。在 十位数的区间，1 会出现在


$$
10 \rightarrow 19
$$
且每隔 100 个数出现一次



Note: 现在讨论的是 `位`上出现1 的可能。21，31 之类的为个位的情况，已经被个位包含在内

---

则
$$
0|10 \rightarrow 0|19 \\
\space \\
2|10 \rightarrow 2|19 \\
\space \\
3|10 \rightarrow 3|19 \\
\space \\
\ldots \space \\
\space \\
315|10 \rightarrow 315|19
$$
一共出现了 315 + 1 次 1



###### 当原数中的十位等于 1 时

假设原数为 `31513`, 其十位数为 1

则
$$
0|10 \rightarrow 0|19 \\
\space \\
2|10 \rightarrow 2|19 \\
\space \\
3|10 \rightarrow 3|19 \\
\space \\
\ldots \space \\
\space \\
314|10 \rightarrow 314|19 \\
\space \\
315|10 \rightarrow 315|13
$$
则 1 一共出现了 （314 + 1）+ 3 + 1 次

###### 当原数中的十位等于 0 时

假设原数为 `31503` ,其 十位数 为 0

则 一共出现了 315 次
$$
0|10 \rightarrow 0|19 \\
\space \\
2|10 \rightarrow 2|19 \\
\space \\
3|10 \rightarrow 3|19 \\
\space \\
\ldots \space \\
\space \\
314|10 \rightarrow 314|19 \\
$$
