---

layout:     post   				    # 使用的布局（不需要改）
title:      Ideas for Data Structure 				# 标题 
subtitle:   Data Structure          #副标题
date:       2019-04-28 				# 时间
author:     WYX 						# 作者
header-img: img/1.6.png 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - data structure

---



### 堆的操作

##### 将一个数组调成最大堆/最小堆

从一个随机数据开始，从最后一个**具有儿子的节点**开始

调整思想如下，以调整为最大堆为例

- 每一个根节点自成一个堆，不需要调整
- 最后一个具有儿子的节点，则当前节点与其儿子节点进行比较
  - 首先选出儿子节点中较大的儿子，利用左儿子的序号 + 1，看是否超出数组来判定是否存在右儿子
  - 当前节点与儿子节点中大的进行比较，如果当前节点比儿子节点下，则进行交换
  - 将当前节点移动到其儿子节点，再与儿子节点的儿子节点进行比较
  - 不断循环，直至达到叶节点

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/createHeap1.jpg" width = "400"/><img src = "https://github.com/joseph-mutu/Pics/raw/master/createHeap2.jpg" width = "400"/>
</center>

#### 堆的插入操作

插入的前提是，当前已经存在一个最大堆/最小堆

<center>
    <img src = "https://github.com/joseph-mutu/Pics/raw/master/maxHeapInsert.jpg" width = "200"/>
</center>



- 先将需要插入的节点直接 `append` 到数组的最后一个元素，然后从当前元素开始寻找其父节点
- 因为排除最后插入的元素，当前为最大堆，则其父节点一定比 **除最后插入的元素以外** 的儿子节点大
- 则若最后插入元素大于其父节点，交换位置，当前位置换为父节点位置，继续比较
- 因为存在岗哨，所以直接比较到无法交换为止



#### 堆的删除操作

删除的前提是，当前为一个最大/最小堆

- 将当前堆的堆顶元素取出，利用 `当前堆的最后元素` 进行代替

- 此时，除堆顶元素外，堆顶元素的左子树以及右子树仍为 最大堆/最小堆
- 将堆顶元素与其左儿子右儿子进行比对，并交换，调整当前位置为其交换的儿子位置
- 一直到叶节点或者无法交换

<center>
    <img src ="https://github.com/joseph-mutu/Pics/raw/master/MaxheapDelete.jpg" width = "200"/><img src = "https://github.com/joseph-mutu/Pics/raw/master/maxHeapDelete2.jpg" width = "400"/>
</center>





### **Saving James Bond - Hard Version**

- 将每一个鳄鱼的坐标看做一个节点，初始节点的坐标为 0,0
- 根据最大跳跃距离为条件，设置每一个节点之间是否连通（如果能跳过去，即为连通）
- dis[节点i] 表示当前节点到原点的最短距离
- 注意，在压入首节点的时候，要将距离从大到小排列再压入
- 使用无权最短路，利用队列，将一个顶点所有联通点进行一次更新



### 最小生成树

#### Prim 算法

在 prim 算法中，以任意节点为起始点，构建一个 cost[1~nodes] 数组，代表当前节点距离当前生成树的最小距离

- 在 cost 数组中，每当添加一个节点进入生成树之后，要对 cost 数组进行更新 ,因为 cost[i] 代表当前节点距离生成树的距离。随着生成树节点的增多，cost也不断变化
  - 以 v5 举例
    - 当生成树包含 v1时， cost[v5] = 999
    - 生成树: v1, v2, cost[v5] = 10
    - 生成树: v1,v2,v4, cost[v5] = 7
    - 生成树:v1,v2,v4,v7, cost[v5] = 6
  - cost[i] 的变化范围就是节点的出度
- 每次选择距离生成树最近的一个节点，将其添加进生成树中。
- 如果没有最小节点可以选择，但是仍旧有节点遗留，说明树不连通

![](https://ae01.alicdn.com/kf/HTB1fHDwT8LoK1RjSZFu760n0XXaB.png)

#### Kruskal 算法

在 Kruskal 算法中，以边为结点，每次选取权重最小但是不能构成回路的边

- 权重最小
- 无法构成回路
- 当边的数目到达 |V-1|(V 是结点的数目)时表示最小生成树完成，跳出

在 Kruskal 分别使用

- 最小堆 --> 挑选权重最小的边

- 并查集 --> 检查回路

  - 在检查回路的时候，是对相应边的两个结点进行合并以及检查
  - 使用路径压缩，使得一棵生成树只有一个父节点
  - 如果并查集中出现两个父节点，说明图不连通

  

### 排序

#### 冒泡排序

具体算法如下：

- 开始指针指向初始数组0以及1位置，如果 data[0] > data[1],交换位置
- 指针移动至 1,2
- 重复交换
- 两重循环

特征

- 最坏的情况为 O($N^2$)

- 每一次遍历最大的值一定会在最底部

  



#### 插入排序

给定一段数据，从下标为 1 的数据开始进行比对

假设给定数据序列为


$$
X = \lbrace3,2,1 \rbrace
$$


假设 X[i] 为手中拿到的牌，X[i-1~0]为已经有的牌，则当前比对的数据序列为


$$
X = \lbrace3,2 \rbrace
$$


记住当前的牌，如果 X[i-1] 大于 X[i], 则将 X[i-1] 向后挪一位，数据序列变为


$$
X = \lbrace3,3 \rbrace
$$


如果比对下标为0，或者不满足X[i-1] 大于 X[i], 寻找到位置，将手中的牌插入。在上述操作当中，将X[0] 挪位之后，i = 0 跳出

```python
def insert_sort(number,data):
	for p in range(1,number):
		tem = data[p]
		for i in range(p,-1,-1):
			if data[i-1] > tem and i > 0:
				data[i] = data[i-1]
			else:
				break
		data[i] = tem
	return data
```





#### 希尔排序

希尔排序会使用插入排序

其核心在于定义增量序列，每次使用插入排序对增量序列进行排序

![](https://ae01.alicdn.com/kf/HTB1ETkCUSzqK1RjSZPcq6zTepXaf.jpg)

#### 堆排序

堆排序的想法是利用最大堆，并且无需用到额外的数组，具体想法如下

- 利用数组存储完全二叉树
- 将完全二叉树调整成最大堆
- 将最大堆的顶端元素与最大堆的最后一个元素对调，同时堆的规模减一
  - 这是因为，在排序的过程中，最大的元素一定是排在最后的
  - 这一举措减少了额外数组的利用，在同一数组内完成排序
- 不断重复上述过程

以下对于完全二叉树调整为最大堆进行总结

- 从最后一个有儿子的节点开始(图中的 43)
  - 这里需要进行判定，最后一个有儿子的节点可能是有一个左儿子，或者存在右儿子
  - 因为其儿子一定就是数组的最后一个元素，根据完全二叉树的性质，可以推出这个有儿子节点的下标
  - 存在右儿子以及不存在右儿子的情况有所不同，要判定
- 得到最后一个有右儿子的节点的下标，将其调整为最大堆
  - 与左右儿子中大的进行比较，如果当前节点比左右儿子中大的那个小，两者互换位置
- 一定从当前节点重复到根节点，则当前完全二叉树被调整为最大堆
  - 需要注意的是，在调整的过程中，跳出的条件，要么是左右儿子都比当前节点小，或者没有儿子



![](https://ae01.alicdn.com/kf/HTB1e7fkVgDqK1RjSZSyq6yxEVXaI.jpg)

#### 归并排序

归并排序的思想简单：

- 假设每一个元素都是一个单独的有序子列
- 不断扩大有序子列的长度，并合并两个有序子列

单独合并的过程如下

- 比较 data[start1] 和 data[start2]，哪个小就拿出来存在临时数组里
- 提取出元素的序列 start1 ++，临时数组的存储位置 ++

![1557639532683](C:\Users\mutudeh\AppData\Roaming\Typora\typora-user-images\1557639532683.png)

总体过程的排序如下：

![1557639708388](C:\Users\mutudeh\AppData\Roaming\Typora\typora-user-images\1557639708388.png)

#### 难点

在归并排序中，难点在于对于尾巴的处理

比如

- 初始时，序列长度为 1，进行合并时以每两个元素一起合并，在当前序列下，则有一个子列遗留
  - 在有一个子列遗留的情况下，直接将最后一个子列的元素，按照其位置导入到临时数组里

$$
\underbrace{4,1,}\underbrace{3,2,} \underbrace{16,9,} \underbrace{10,14,} \underbrace{8,7} 11
$$

- 继续进行，序列长度*2，则当前序列长度为 2
  - 可以看到，在当前序列长度为 2 的情况下，完整的序列对（也就是 2 个长度为 2 的序列）只有两对，最后有大于一个子列（长度为2）存在
  - 在这种情况下，需要进行比对
    - start1 为 8 的位置
    - start2 为 11 的位置

$$
\underbrace{[1,4],[2,3]},\underbrace{[9,16],[10,14]},[7,8],[11]
$$

- 序列长度 * 2, 完整的序列对只有一对（当前长度为 4），遗留一个序列，导入临时数组
  - 如何判别当前序列长度下，有多少个完整的序列对以及遗留一个序列，还是两个序列（一个完整，一个不完整）
    - 完整的序列对，$pairs = int(len(data)/2*length)$
      - 以当前数据举例，数据长度为11,则 int(11/8) = 1
    - 判断遗留，pass 所有完整序列，在当前位置（下式中data[9] = 7 的位置）加上一个序列长度（序列长度为 4），如果小于总数据长度，则表示当前遗留两个序列
      - 否则的话，表示当前只有一个序列，无需进行merge，直接将最后一个序列导入到临时数组

$$
\underbrace{[1,2,3,4],[9,10,14,16]},[7,8,11]
$$

- 序列长度 *2，当前序列长度为 8，完整的序列对（2个8）为0，此时完整序列为 0，进行判断遗留子列
  - 0 + 8（当前序列长度） = 8 < 11, 则有两个遗留子列
  - 对两个遗留子列进行合并，start1 = 0，start2 = 0+8

$$
[1,2,3,4,9,10,14,16],[7,8,11]
$$



#### 快速排序 

#### 表排序

#### 基数排序



#### 散列表 hash table

所谓散列表就是将需要存储的数据，根据一个定义的函数，一次计算出其应该存在的位置，然后将数据在该位置进行存储

因为根据某一函数计算出的位置可能会有冲突，在构造散列函数的时候要考虑这点

![](https://ae01.alicdn.com/kf/HTB1nlRjXBGw3KVjSZFDq6xWEpXau.jpg)



![](https://ae01.alicdn.com/kf/HTB1VxNfXBWD3KVjSZFsq6AqkpXav.jpg)





### 解决hash table 的冲突

因为在计算位置的过程种，无法保证唯一性，则需要有不同的方法解决冲突

#### 线性探测

所谓线性探测，就是当前位置存在冲突，则意味到 i + 1的位置，进行查询，如果 i+1 的位置没有元素，则将当前元素放置在 i+1

![](https://ae01.alicdn.com/kf/HTB1BhNkXBCw3KVjSZR0q6zcUpXa1.jpg)



##### 线性探测的性能分析

性能分析分为两部分：

- 成功平均查找长度
- 不成功平均查找长度

###### 成功平均查找长度

平均查找长度只需要考虑**表中存在的元素**，对于这些元素来说平均需要几次查找。拿元素 11 和 30 来举例。对于该散列表来说，散列函数为 


$$
data ~ mod \ 11
$$


则 11 的位置为 0。30 的位置 为 7。 0 的位置没有元素，可以放。所以查找时，只需要计算其位置就可以找到，所以查找次数为 1。而 7 的位置存在元素，则根据线性探测的定义，一直向右移动，直到没有元素的位置为止，则其查找次数为 7。

###### 不成功平均查找长度

不成功的查找长度，需要考虑**整个散列表的长度**。也就是说考虑，当前位置存在元素的情况下，平均需要查找几次（也就是需要移动几次，才能找到一个空位置，找到空位置就说明冲突的元素可以被找到了）。

拿 data[0] 来举例，如果来了另一个元素的位置为 0，则根据线性探测的定义，要向右移动 2 到达 data[2]，才能将冲突元素放置，意味着要查找这个 “另一个元素” 需要查找 3 次。	

![](https://ae01.alicdn.com/kf/HTB15ZRmXq1s3KVjSZFAq6x_ZXXar.jpg)

##### 平方探测

与线性探测一次向右一个位置不同，平方探测以下图增量序列移动

![](https://ae01.alicdn.com/kf/HTB1q68hXAWE3KVjSZSyq6xocXXaG.jpg)

但是平方探测存在问题，有的位置可能会到达不了。所以在构建散列表的过程中，**需要以素数大小建表**

![](https://ae01.alicdn.com/kf/HTB1fZFnXBCw3KVjSZFuq6AAOpXaA.jpg)	