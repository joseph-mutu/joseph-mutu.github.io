---
layout:     post   				    # 使用的布局（不需要改）
title:      Ideas for Data Structure 				# 标题 
subtitle:   Data Structure          #副标题
date:       2019-04-28 				# 时间
author:     WYX 						# 作者
header-img: img/1.6.png 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - data structure

---



# **Saving James Bond - Hard Version**

- 将每一个鳄鱼的坐标看做一个节点，初始节点的坐标为 0,0
- 根据最大跳跃距离为条件，设置每一个节点之间是否连通（如果能跳过去，即为连通）
- dis[节点i] 表示当前节点到原点的最短距离
- 注意，在压入首节点的时候，要将距离从大到小排列再压入
- 使用无权最短路，利用队列，将一个顶点所有联通点进行一次更新



# 最小生成树

## Prim 算法

在 prim 算法中，以任意节点为起始点，构建一个 cost[1~nodes] 数组，代表当前节点距离当前生成树的最小距离

- 在 cost 数组中，每当添加一个节点进入生成树之后，要对 cost 数组进行更新 ,因为 cost[i] 代表当前节点距离生成树的距离。随着生成树节点的增多，cost也不断变化
  - 以 v5 举例
    - 当生成树包含 v1时， cost[v5] = 999
    - 生成树: v1, v2, cost[v5] = 10
    - 生成树: v1,v2,v4, cost[v5] = 7
    - 生成树:v1,v2,v4,v7, cost[v5] = 6
  - cost[i] 的变化范围就是节点的出度
- 每次选择距离生成树最近的一个节点，将其添加进生成树中。
- 如果没有最小节点可以选择，但是仍旧有节点遗留，说明树不连通

![](https://ae01.alicdn.com/kf/HTB1fHDwT8LoK1RjSZFu760n0XXaB.png)

## Kruskal 算法

在 Kruskal 算法中，以边为结点，每次选取权重最小但是不能构成回路的边

- 权重最小
- 无法构成回路
- 当边的数目到达 |V-1|(V 是结点的数目)时表示最小生成树完成，跳出

在 Kruskal 分别使用

- 最小堆 --> 挑选权重最小的边

- 并查集 --> 检查回路

  - 在检查回路的时候，是对相应边的两个结点进行合并以及检查
  - 使用路径压缩，使得一棵生成树只有一个父节点
  - 如果并查集中出现两个父节点，说明图不连通

  

# 排序

## 冒泡排序

具体算法如下：

- 开始指针指向初始数组0以及1位置，如果 data[0] > data[1],交换位置
- 指针移动至 1,2
- 重复交换
- 两重循环

特征

- 最坏的情况为 O($N^2$)

- 每一次遍历最大的值一定会在最底部

  



## 插入排序

给定一段数据，从下标为 1 的数据开始进行比对

假设给定数据序列为


$$
X = \lbrace3,2,1 \rbrace
$$


假设 X[i] 为手中拿到的牌，X[i-1~0]为已经有的牌，则当前比对的数据序列为


$$
X = \lbrace3,2 \rbrace
$$


记住当前的牌，如果 X[i-1] 大于 X[i], 则将 X[i-1] 向后挪一位，数据序列变为


$$
X = \lbrace3,3 \rbrace
$$


如果比对下标为0，或者不满足X[i-1] 大于 X[i], 寻找到位置，将手中的牌插入。在上述操作当中，将X[0] 挪位之后，i = 0 跳出

```python
def insert_sort(number,data):
	for p in range(1,number):
		tem = data[p]
		for i in range(p,-1,-1):
			if data[i-1] > tem and i > 0:
				data[i] = data[i-1]
			else:
				break
		data[i] = tem
	return data
```





## 希尔排序

希尔排序会使用插入排序

其核心在于定义增量序列，每次使用插入排序对增量序列进行排序

![](https://ae01.alicdn.com/kf/HTB1ETkCUSzqK1RjSZPcq6zTepXaf.jpg)

# 堆排序

堆排序的想法是利用最大堆，并且无需用到额外的数组，具体想法如下

- 利用数组存储完全二叉树
- 将完全二叉树调整成最大堆
- 将最大堆的顶端元素与最大堆的最后一个元素对调，同时堆的规模减一
  - 这是因为，在排序的过程中，最大的元素一定是排在最后的
  - 这一举措减少了额外数组的利用，在同一数组内完成排序
- 不断重复上述过程

以下对于完全二叉树调整为最大堆进行总结

- 从最后一个有儿子的节点开始(图中的 43)
  - 这里需要进行判定，最后一个有儿子的节点可能是有一个左儿子，或者存在右儿子
  - 因为其儿子一定就是数组的最后一个元素，根据完全二叉树的性质，可以推出这个有儿子节点的下标
  - 存在右儿子以及不存在右儿子的情况有所不同，要判定
- 得到最后一个有右儿子的节点的下标，将其调整为最大堆
  - 与左右儿子中大的进行比较，如果当前节点比左右儿子中大的那个小，两者互换位置
- 一定从当前节点重复到根节点，则当前完全二叉树被调整为最大堆
  - 需要注意的是，在调整的过程中，跳出的条件，要么是左右儿子都比当前节点小，或者没有儿子



![](https://ae01.alicdn.com/kf/HTB1e7fkVgDqK1RjSZSyq6yxEVXaI.jpg)

## 归并排序

归并排序的思想简单：

- 假设每一个元素都是一个单独的有序子列
- 不断扩大有序子列的长度，并合并两个有序子列

单独合并的过程如下

- 比较 data[start1] 和 data[start2]，哪个小就拿出来存在临时数组里
- 提取出元素的序列 start1 ++，临时数组的存储位置 ++

![1557639532683](C:\Users\mutudeh\AppData\Roaming\Typora\typora-user-images\1557639532683.png)

总体过程的排序如下：

![1557639708388](C:\Users\mutudeh\AppData\Roaming\Typora\typora-user-images\1557639708388.png)

### 难点

在归并排序中，难点在于对于尾巴的处理

比如

- 初始时，序列长度为 1，进行合并时以每两个元素一起合并，在当前序列下，则有一个子列遗留
  - 在有一个子列遗留的情况下，直接将最后一个子列的元素，按照其位置导入到临时数组里

$$
\underbrace{4,1,}\underbrace{3,2,} \underbrace{16,9,} \underbrace{10,14,} \underbrace{8,7} 11
$$

- 继续进行，序列长度*2，则当前序列长度为 2
  - 可以看到，在当前序列长度为 2 的情况下，完整的序列对（也就是 2 个长度为 2 的序列）只有两对，最后有大于一个子列（长度为2）存在
  - 在这种情况下，需要进行比对
    - start1 为 8 的位置
    - start2 为 11 的位置

$$
\underbrace{[1,4],[2,3]},\underbrace{[9,16],[10,14]},[7,8],[11]
$$

- 序列长度 * 2, 完整的序列对只有一对（当前长度为 4），遗留一个序列，导入临时数组
  - 如何判别当前序列长度下，有多少个完整的序列对以及遗留一个序列，还是两个序列（一个完整，一个不完整）
    - 完整的序列对，$pairs = int(len(data)/2*length)$
      - 以当前数据举例，数据长度为11,则 int(11/8) = 1
    - 判断遗留，pass 所有完整序列，在当前位置（下式中data[9] = 7 的位置）加上一个序列长度（4）如果小于总数据长度，则表示当前遗留两个序列
      - 否则的话，表示当前只有一个序列，无需进行merge，直接将最后一个序列导入到临时数组

$$
\underbrace{[1,2,3,4],[9,10,14,16]},[7,8,11]
$$

- 序列长度 *2，当前序列长度为 8，完整的序列对（2个8）为0，此时完整序列为 0，进行判断遗留子列
  - 0 + 8（当前序列长度） = 8 < 11, 则有两个遗留子列
  - 对两个遗留子列进行合并，start1 = 0，start2 = 0+8

$$
[1,2,3,4,9,10,14,16],[7,8,11]
$$



## 快速排序 

## 表排序

## 基数排序





