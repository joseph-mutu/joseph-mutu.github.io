---
layout:     post   				    # 使用的布局（不需要改）
title:      动态规划				# 标题 
subtitle:   dynamic programming           #副标题
date:       2020-03-13 				# 时间
author:     WYX 						# 作者
header-img: img/1.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - dynamic programming 

---

---

本文记录动态规划相关想法

---



## 动态规划

#### 647 回文子串



使用动态规划求解：

- `dp[i][j]` 意思是从 i 到 j （闭区间）的子串**是否为回文子串**(True/False)
- 当子串数目为 2 时，如果两个`s[i] == s[j]` 则该子串一定为回文子串
- 当子串数目为 3 时，如果首尾相等，同样一定为回文子串。
  - 举例 `aba` `aca` `ada`
- 当首尾相差大于 2 时，如果首尾相等，则需要检查 `dp[i+1][j-1]` 也就是中间的子串，且此时 `dp[i+1][j-1]` 已经求解完毕

下面叙述遍历过程

- 从子串最后一位开始，a == a 则 `dp[4][4] = True`
- 从倒数第二位开始
  - b == b, `dp[3][3] = True`
  - b !=a, `dp[3][4] = False`
- 需要重复用到dp的在 `dp[0][4]` 时
  - a == a, 此时查找 `dp[1][3]` 

<img src="https://github.com/joseph-mutu/Pics/raw/master/data structure/palindrome.png" style="zoom:43%;" />

#### 718 最长重复子数组

与最长重复子序列意思相近，子数组要求必须连续

同样使用 dp。但是更新的规则只有一个

- ```python
  if A[i] == B[j]:
  	dp[i][j] = dp[i-1][j-1] + 1
  else:
      dp[i][j] = 0
  ```

![](https://pic.leetcode-cn.com/b190e4cb2e9c3b6c81a633de8ce11da922df5b21629b9746e700d55b63c473f5-da.png)

#### 300 最长上升子序列

有两种动态规划数组的设计方法

- 包含当前位置数字的最长上升子序列的长度
- `dp[i]` 记录长度为 `i` 时，最小的尾部元素为 `dp[i]`

**`dp[i]` 记录长度为 `i` 时，最小的尾部元素为 `dp[i]`**

>  `dp[i]` 数组一定为非递减序列 

假设有 $ dp[i+1] < dp[i]$ ， 则表示 i +1 处的元素可以接在长度为 i 的元素下，此处与定义不符

每当遍历一个新的数字时，从 `0 ~ res` 的范围内搜索 **第一个大于当前数字** 的值，然后进行更新

- 若没有找到，则将 dp 数字扩展 1，并将当前元素赋值给新的扩展

> 如何寻找第一个大于当前数字的值

**二分法**

```python
res = 0 # res 表示当前的最大上升子序列长度，初始为 0
l = 0, r = res
while l < r:
    mid = (l+r)//2
    if mid < num:
        left = mid + 1
   	else:
        right = mid
# 跳出循环后，分为两种情况
- right == left 返回第一个大于当前数字的值
- left 超出 res 范围 = res + 1
	- 这种情况下 right 不动，也就是数组中所有数字均小于当前数
if right == res:
    res += 1
```

#### 42 接雨水

**从暴力法开始，如何计算当前位置的雨水数目**

- 找到当前位置左边的最高的元素
- 找到当前位置右边最高的元素
  - 两者之间最小的元素为当前位置雨水的高度
- 当前位置雨水的高度减去当前的高度，即为当前位置雨水数目

```python
water = 0
for i in range(1,len(height)):
    max_left,max_right = 0,0
    
    for left in range(i):
        max_left = max(height[left],max_left)
    for right in range(i,len(height)):
        max_right = max(height[right],max_right)
    water += min(max_left,max_right) - height[i]
return water
```

**动规优化**

分别使用两个数组存储当前位置的`max_left` 和 `max_right`

**双指针优化动规空间复杂度**

上述 `max_left[i] = max(max_left[i-1],height[i-1])`

`max_right[i] = max(max_right[i+1],height[i+1])`

最终当前位置的高度取决于 `max_left[i]` 以及 `max_right[i]` 之间的最小值

- 且计算雨水时，要从1的位置开始，0 以及 height[-1] 的位置为边界值

则可以使用两个指针分别指向 0,以及 height[-1] 

- 如果左边小，则更新左边的位置，然后更新 max_left 的值
- 如果右边小，则更新右边的位置，然后更新 max_right 的值

#### 322 兑换硬币

**解法**

`dp` 数组存储在 `amount` 的钱数下，所需要的最小硬币数

- 首先确定状态，什么为在当前问题以及子问题中持续变换的量

  - 目标钱数 amount

- 如果给定转移方程

  - ```python
    for coin in coins:
    	dp[amount] = min(dp[amount],1+dp[amount - coin])
    ```

- 从`amount = 1` 开始，其中 `dp[0] = 0`

- `dp[amount]` 除 0 外初始化为 `amount + 1`

#### 139 单词拆分

**暴力解法**

给定一个字符串，搜索所有可能的子串

```python
if start == len(string):
	return True
for end in range(start + 1,len(string) + 1):
    if string[start : end] in word_dict and self.check(end):
        return True
return False
```

- `string[start : end]` 以 end 为界限，end 之前的单词若存在于字典中，则继续判断 end 之后的单词

**暴力解法 + 记忆数组**

现对给定字符串 `aaab` 以及字典 `a,aa,aaa` 进行分析

- `start = 0, end = 1` 表示尝试第一个分界点在 1 处
  - `a` 存在于字典中，搜索 `aaab`, 此时 start = 1
    - `aaab` 返回 False，因为无论怎样切分都无法分割成字典中的单词
  - `end  = 2` ，`aa` 存在于字典中，搜索 `ab` 
    - 在第一次搜索 `aaab` 时，已经对 `ab`进行过求解，若不加存储，则仍然需要再次搜索

Note: 建立记忆化数组，存储从当前位置到末尾的求解结果，即

- memo[i] 表示 `i:len(string) + 1` 的搜索结果，为 True 或者 False

**动态规划**

建立动态规划数组，定义为从 `0:i-1` 这一段的子串是否可以被字典完全切割

`dp[0] = True` 为 Base case

- 判断时，根据切分点，分为dp数组并判断后一段是否存在于字典中

最后返回 dp 数组的最后一个值