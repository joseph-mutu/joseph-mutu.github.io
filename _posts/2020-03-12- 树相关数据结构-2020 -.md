---
layout:     post   				    # 使用的布局（不需要改）
title:      树相关数据结构				# 标题 
subtitle:   Data Structure           #副标题
date:       2020-03-12 				# 时间
author:     WYX 						# 作者
header-img: img/qihuan1.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - Data Structure 

---

---

本文记录与树相关的数据结构，包括遍历，最短路等

---



## 二叉树

#### 124 二叉树的最大路径和

**解法**

注意区分每个节点的 `局部最大` 和 `能传递最大`

所谓局部最大表示无法从当前节点传递到其父节点的路径最大值，包括

- 左子树路径最大
- 右子树路径最大
- 左子树路径 + 右子树路径 + 当前节点，即当前节点连通，但是与父节点不连通

采用 `self.max` 更新局部最大

所谓 `能传递最大` 包含连通路径

- 仅当前节点
- 左子树路径+ 当前节点
- 右子树路径 + 当前节点

最后将 `self.max` 与能连通最大进行比较

#### 235 二叉搜索树的最近公共节点

**解法**

因为是二叉搜索树，所以存在特性

- 左边的节点全部小于根节点
- 右边的节点全部大于根节点

最近公共节点的判定分为三种情况

- 如果 `p` 和 `q` 节点的值一个大于根节点一个小于根节点，则直接返回根节点

- 如果 `p` 和 `q` 节点均小于根节点，也就是都在左边

```python
LCS = self.lowestCommonNode(root.left,p,q)
```

- 如果 `p` 和 `q`节点均大于根节点，都在右边

```python
LCS = self.lowestCommonNode(root.right,p,q)
```

#### 二叉树的最近公共节点

**解法1**

使用 DFS 或者 BFS 先找出通往两个节点的路径，将两个路径存储。从一条路径的最后一个节点开始遍历，找到第一个同时存在于两个路径之间的节点，该节点即为公共节点

**解法2**

递归求解，分情况讨论

- 若 两个节点分属于 root 节点的两侧，则当前root节点即为返回节点
- 若两个节点全在与 root 节点的 左侧，则 

```python
left = self.lowestCommonAncestor(self,root.left,p,q)
```

left 返回左侧两个节点的 LCA 节点

```python
right = self.lowestCommonAncestor(self,root.right,p,q)
```

right 返回 None

- 若两个节点全在 root 节点的右侧，则

```python
left = self.lowestCommonAncestor(self,root.left,p,q)
```

left 返回 none

```
right = self.lowestCommonAncestor(self,root.right,p,q)
```

right 返回两节点的 LCA

总结为，若 left 不为 None，则返回 left，否则返回 right；若 left 和 right 同时不为 None，则返回 root

## 搜索图

#### 277 搜寻名人

> 名人为某一行除 matrix[i,i] 元素为，其余均为 0

则可以利用上述性质，寻找可能的一行

- 假设名人为 0

- 从 0 开始，如果 not Knows(cle, i)，则 cle 变为 i
  - 这利用了 cle 所在行均为 0
- 遍历完成后，需要进行验证，因为无法保证 cle 前面的所有人都认识 cle并且 cle 不认识前面的所有人，且无法保证 后面的所有人都认识 cle

#### 994 腐烂的橘子

**解法**

多元广度搜索，同时从多个点开始进行广度搜索，并记录当前位置距离其源点的路径长度

Note: 一个位置可以被多个不同的源点接触到，但是只取路径最小的一个值

在添加节点进入 `node_list` 时，同时添加 `dis` 变量表示从源点出发经过的距离

#### 22 生成括号

给定一个数字 `n`，要求给出 `n` 对括号所有可能的组合

**解法1**

利用深度优先搜索

- 每一个节点的值代表一个括号，可以是左括号，也可以是右括号
- 每一个节点中包含左边剩余的括号数，以及右边剩余的括号数
  - 如果要使生成的括号合法，则左边剩余的括号数要 `大于等于` 右边剩余的括号数
  - 否则剪枝
- 当左边剩余括号数以及右边剩余括号数均为 0 时，将当前路径添加进列表中，表示一种可能的组合



**解法2**

动态规划

- 建立 dp 字典，其中 `dp[i]` 包含给定 `i` 时所有可能的组合
  - `dp[0] = [[None]]`, `dp[1] = ["()"]`
- 考虑 `dp[i + 1]` 与之前 dp 数组的关系
  - 之前的括号只能存在于新进括号的里面或者外面，“（`dp[p]`）`dp[q]`” ，其中 `p+q = i`
- `dp[2]` 举例
  - dp[2] = "`(dp[0])dp[1]`" ，"`(dp[1])dp[0]`"
  - = "()()","(())"